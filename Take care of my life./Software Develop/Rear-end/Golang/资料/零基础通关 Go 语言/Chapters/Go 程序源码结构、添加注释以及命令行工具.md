## Go程序源码结构

我们继续探索 Hello World 程序的奥秘，先来回顾完整的代码：

```Go
package main

import "fmt"

func main(){
    fmt.Println("Hello World!")
}
```

接下来，我们逐行解释代码。

> 💡 提示： 作为Go语言基础部分，本小节的内容仅对每行代码做功能性解释，不做深入探讨，我们将在后续的章节中详细阐述。例如，对于“main包”，我们暂时只需要对“包”和“main包”有个印象就可以了。

1. 第一行内容为 `package main`，它表示这个源码文件属于 main 包。main 包是每个 Go 应用程序都包含的包，有且仅有一个。
2. 第二行内容是 “import “fmt"”，它的作用是导入名为 “fmt” 的包，目的在于稍后使用 fmt 包提供的各种能力。一旦某个包被导入，它必须被使用。
3. 从第三行开始到最后，是 main() 函数，这个函数比较特殊，它是 Go 程序的“入口”函数，是程序运行的起点。这个函数必须存在且只能存在一个，且必须声明在 main 包中。任何一个 Go 函数都要求使用成对的大括号将函数体包裹起来。
4. 第四行调用了 fmt 包中的 Println() 函数，这个函数的作用是将特定的内容输出到控制台上。
5. 第五行是 main() 函数的结束。

## 为 Go 源码添加注释

无论使用何种编程语言，为代码添加注释都是必要的。注释的作用是对代码进行解释和说明，目的在于让人们更方便地了解代码。

对于大多数项目，都需要持续一段时间来完成开发和测试，最终上线，上线后还要应对产品的迭代更新。然而，毫不夸张地说，即使仅相隔一周，我们便很可能读不懂代码了，即使这些代码是自己亲手写的。此时，注释就能很好地帮助我们理解这些代码了。

在 Go 语言中，注释分为两类：单行注释和多行注释。

### 单行注释

单行注释也称为行注释，格式为以双斜杠（“//”）开头的一行，可以添加在代码的任何位置。

请大家阅读下面的代码：

```Go
go
复制代码
package mainimport "fmt"func main(){   //输出"Hello World!"文字   fmt.Println("Hello World!")}
```

在这段代码中，添加了一行注释，用于解释下方一行代码的作用。

需要注意的是，在使用注释时，不要连同代码一起注释，被注释的代码不会被执行。但在修改代码时，利用这个特性暂时注释掉将被修改的代码，而非直接删除，可以方便在必要时还原它们。

若要添加空白行，可按照如下格式进行：

```Go
//第一行////第三行//第四行
```

### 多行注释

多行注释也称为块注释，格式为以 “/_” 开头，以 “_/” 结束的一行或多行。

请大家阅读下面的代码：

```Go
/*
main()函数是Go程序的入口函数是程序运行的起点
此处输出"Hello World!"用于验证开发环境配置 
*/
func main(){   //输出"Hello World!"文字   
    fmt.Println("Hello World!")
}
```

本例在 main() 函数上方添加了多行注释，用于解释 main() 函数的作用。

和单行注释不同，多行注释不允许嵌套使用，如：

```Go
/*main()函数是Go程序的入口函数/*是程序运行的起点此处输出"Hello World!"*/用于验证开发环境配置 */
```

这将导致编译时错误，无法完成编译。

若要添加空白行，可按照如下格式进行：

```Go
/*第一行第三行第四行 */
```

《代码大全》一书中有提到：“代码是写给人看的”。养成良好的编码习惯不仅对编码本身有利，对开发团队中的队友也是很好的支持。在实际开发中，人员之间的沟通成本可能会庞大到可怕，请大家谨记。

## Go SDK 命令行工具

Go SDK 提供了丰富且实用的命令行工具，涵盖编译、代码格式化、源码获取、测试和性能分析（这部分内容在单独的章节中阐述）等方方面面，本节将为大家介绍常用的工具。

``💡 提示：在后面的章节中，我们会介绍使用集成开发环境（IDE）开发、编译和运行 Go 程序。在 IDE 中可以通过可视化的方式执行 Go SDK 中的命令行工具，但作为基础知识的一环，且在实际开发的某些场景下依然需要通过终端执行这些命令，因此了解并掌握这些命令行工具依然很重要。

### go build

go build 命令的作用是编译 Go 源码，并生成可执行的文件。还记得吗？在上一节中我们已经使用过它了！

从原理上说，Go SDK 自 1.9 版本开始就支持并发编译了，能尽可能地发挥电脑的最大性能完成编译，所以 Go 源码的编译速度是非常快的。在编译过程中，除了我们自己写的代码外，如果使用了第三方的包，这些包会被一同编译。当我们执行 go build 命令后，会搜索当前目录下的 go 源码并完成编译。

go build 命令还允许附加参数，方便开发者对编译参数进行配置，具体如下表所示：

此外，如果我们希望只编译某个 go 源码文件或包，可在 go build 命令后添加文件或包名。例如，现有 file1.go、file2.go 和file3.go，我们只希望编译 file1.go，便可如下执行：

```Bash
go build file1.go
```

### go clean

go clean 命令可以清理当前目录内的所有编译生成的文件，具体包括：

- 当前目录下生成的与包名或者 Go 源码文件同名的可执行文件，以及当前目录中 _obj 和 _test 目录中名为 _testmain.go、test.out、build.out、a.out 以及后缀为.5、.6、.8、.a、.o和 .so 的文件，这些文件通常是执行go build命令后生成的；
- 当前目录下生成的包名加 “.test” 后缀为名的文件，这些文件通常是执行 go test 命令后生成的；
- 工作区中 pkg 和 bin 目录的相应归档文件和可执行文件，这些文件通常是执行 go install 命令后生成的。

go clean 命令还允许附加参数，具体参数和作用如下表所示：

在团队式开发中，通常在每次提交代码前执行 go clean 命令，防止提交编译时生成的文件。
### go run

go run 命令的作用是直接运行 go 源码，不在当前目录下生成任何可执行的文件。

从原理上讲，go run 只是将编译后生成的可执行文件放到临时目录中执行，工作目录仍然为当前目录。同时，go run 命令允许添加参数，这些参数将作为 go 程序的可接受参数使用。

由此可见，go run 命令同样会执行编译操作。但要注意的是，go run 不适用于包的执行。

### gofmt

gofmt 命令的作用是将代码按照Go语言官方提供的代码风格进行格式化操作。

请大家注意，**gofmt和go fmt是两个不同的命令**。go fmt 命令是 gofmt 的封装，go fmt 支持两个参数：-n 和 -x，分别表示仅输出格式化时执行的命令，以及执行格式化并输出格式化时执行的命令。

执行 gofmt 命令时，可指定文件或目录，也可不指定。当不指定时，gofmt 命令会搜索当前目录中的 go 源码文件，并执行相应的格式化操作。

gofmt 命令还允许附加参数，具体参数和作用如下表所示：

	💡 提示：使用-s参数进行源码简化的规则请参考：https://pkg.go.dev/cmd/gofmt#hdr-The_simplify_command

### go install

go install 命令的作用和 go build 类似，都是将源码编译为可执行的文件，附加参数也基本通用，这里就不再赘述了。区别在于：

- go install 命令在编译源码后，会将可执行文件或库文件安装到约定的目录下；
- go install 命令生成的可执行文件使用包名来命名；
- 默认情况下，go install 命令会将可执行文件安装到 GOPATH\bin 目录下，依赖的三方包会被安装到 GOPATH\bin 目录下。

### go get

go get 命令的作用是获取源码包，这一操作包含两个步骤，分别是下载源码和执行 go install 命令进行安装。使用时，仅需将源码仓库地址追加到 go get 后即可（访问[pkg.go.dev/](https://link.juejin.cn/?target=https%3A%2F%2Fpkg.go.dev%2F)，搜索包名，在包详情页可以找到仓库地址），例如：

```Bash
go get github.com/ethereum/go-ethereum
```

go get 命令还允许附加参数，具体参数和作用如下表所示：

|   |   |
|---|---|
|参数名|作用|
|-v|编译时显示包名|
|-p x|指定编译时并发的数量（使用x表示），该值默认为CPU的逻辑核心数|
|-a|强制进行重新构建|
|-n|仅输出编译时执行的所有命令|
|-x|执行编译并输出编译时执行的所有命令|
|-race|开启竞态检测|

若要指定所获取源码包的版本，可以通过添加 “@版本号” 的方式执行。如：

```Bash
go get github.com/ethereum/go-ethereum@v1.10.1
```

在使用 Go SDK 1.17 版本时，有一点需要额外注意：执行 go get 命令可能会收到警告，大意是 go get 命令是不建议使用的。此时，使用go install替换 go get 即可，原因是在未来的 Go SDK 版本中 go get 的作用等同于 go get -d。

如果你对 “go get” 命令感兴趣，可以阅读官方对它的说明，写的非常详细：[docs.studygolang.com/doc/go-get-…](https://link.juejin.cn/?target=https%3A%2F%2Fdocs.studygolang.com%2Fdoc%2Fgo-get-install-deprecation)

## 小结

🎉 恭喜，您完成了本次课程的学习！

📌 以下是本次课程的重点内容总结，需要牢牢把握：

1. 了解 Hello World 每行源码的含义，了解 Go 程序源码的结构；
    
2. 掌握为源码添加注释的两种方法；
    
3. 熟练使用 Go SDK 提供的命令行工具（6 个 Go SDK 命令），包括每个命令的参数。
    

➡️ 在下次课程中，我们会阐述如下内容：

1. Go 语言集成开发环境介绍（使用 GoLand ）
2. 如何使用 GoLand 创建、编译和运行 Go 程序；
3. 如何使用 GoLand 进行 Go 代码调试。

# 集成开发环境的使用

本小节将为大家介绍有关 Go 语言的集成开发环境的介绍和使用，具体涉及三个方面，包括简要介绍、基本使用和代码调试技巧。

其中，基本使用和代码调试在日常开发中使用最为频繁，本文将手把手带你完成这些工作。

在正式开始之前，需要先统一使用集成开发环境和 Go SDK 版本。集成开发环境我们将采用 JetBrains 公司的 GoLand 为例；在本小册的第一讲中，我们已经统一使用 Go SDK 1.17.x 版本为例了，这里再次强调一遍。

> 💡 提示： 目前，支持Go语言的集成开发环境除了 GoLand 外，还有VS Code、Sublime、Eclipse 等等。其中最为强大的便是 GoLand 了，所以我们使用它。

你可能也发现，我们小册并没有提到以何种操作系统为例，原因是无论 GoLand 还是 Go SDK 都支持在常见的操作系统（Windows、macOS和Linux）中安装和使用。



# 基础语法一｜变量和常量、声明、基本类型

我们日常玩的电脑游戏、手机上运行的各类软件、甚至是操作系统都是以数据的管理和计算为基础的，那么这些数据是如何在计算机中安家的呢？这就涉及到了编程语言中的基本语法内容了，这节课我们一起来看一下Go语言的基础语法。具体包括以下内容：

- 变量与常量
    
- 声明与赋值
    
- 基本数据类型
    

`💡 提示： 为易于大家领会要点，节约篇幅，在文末有3个附录。大家可结合相应的知识点进行查阅和实践。`

## 变量与常量

与大多数编程语言类似，Go语言支持声明变量与常量，Go语言程序在运行时，会把所需的数据加载到内存中，这些数据又分为常量和变量，它们的定义也很好理解：

- 常量是一个简单值的标识符，在程序运行时，不会被修改的量；
    
- 变量来源于数学，是计算机语言中能储存计算结果或能表示值的抽象概念，它的值通常是可变的。
    

为何要将数据分为可变的变量和不可变的常量？答案是：为了程序**更快**、**更安全**。

- 更快：虽然常量和变量都会占用内存，但它们位于不同的位置，常量会在编译后放在数据段内存；变量放在代码段内存。合理地使用常量将加快编译速度与减少运行时的内存占用。
    
- 更安全：由于常量不可变，因此我们就没有机会将其误改为其它的值。
    

变量与常量本身很好理解，这里就不过多解释了，需要注意的是它们的命名。

无论是常量还是变量，我们都可以通过它们的名字访问它们。**Go语言中包含25个关键字和37个保留字（参考附录一），在起名字的时候要注意避开它们。**

如果错误地使用了关键字或者保留字作为名字，编译器便无法区分到底该作为名字处理，还是当作本身的作用处理，因此会引发编译时错误。使用GoLand会帮助我们规避这类问题，例如下面的代码：

```Go
//变量声明
var break = "打断"
```

由于break本身属于流程控制类的关键字，代码无法被编译。

在实际开发中，不同的开发者起名字的习惯不同，往往会导致代码的可读性降低甚至引起歧义。比如，把变量命名为a1、a2、a3……时间久了之后几乎没有人能一下子看懂它们代表什么含义，包括代码的作者。因此，一个好的习惯是尽量使用能表达其含义的一个或多个英文单词来命名。

- 对于变量，除了首个单词外，每个单词的首字母用大写表示，这种命名法通常被称为小驼峰式命名法；若所有单词的首字母均大写，则成为大驼峰式命名法（又被称为帕斯卡命名法）。由于变量有可见性（有关可见性的更多内容，将在结构体/包中介绍。）之分，对于对外可见的变量，使用大驼峰法；对于对外不可见的变量，使用小驼峰法。特别地，若变量/常量是布尔类型，最好以is、allow、has、can之类来开头；
    
- 对于常量，单词均用大写字母来表示，每个字母之间使用下划线来分割。
    

例如：

```Go
//变量声明
var exampleNumberA int = 10
var isDarkMode bool = false
//常量声明
const WIDTH_OF_RECT int = 12
const ALLOW_DOWNLOAD_WHEN_WIFI bool = true
```

`💡 提示： 本小册中的所有示例代码均按照上述规则对变量/常量命名。`

`❗️ 注意： Go语言是区分大小写的，exampleNumberA和ExampleNumberA是两个不同的变量。`

Go语言中的命名规范除了体现在变量/常量的命名上，还体现在包名、源码文件名等多个方面，具体请参考文末附录二。

## 声明与赋值

从定义上看，声明是指：

> 当一个计算机程序需要调用内存空间时，对内存发出的“占位”指令，称为：“声明”。

通俗地讲，我们使用的软件都是从硬盘加载到内存，然后在内存中运行的，因为内存和CPU之间交换数据的速度更快。除了程序运行的逻辑外，必要的数据必然也会被加载到内存中。而声明的目的就是在计算机的内存中占用一定大小的空间，用来存放数据。

**在Go语言中，变量或常量的****数据类型****必须先声明，才能使用**，且无法将不相关的数据赋值给它们。

这是因为Go语言和Java、C、C++等语言一样，属于静态语言，静态语言具有更严谨的结构要求、调试便捷（可通过代码直观地看到数据类型）与确保类型安全（无法使用不同类型的数据赋值）的特点，必须要先做声明。而像PHP、Python、JavaScript等动态语言则没有这个限制。

从根本上说，静态类型和动态类型语言的最大区别就是，**数据类型****是否在编译时确定。**

`💡 提示： 如果想要计算机运行人类编写的Go语言代码，需要先编译再运行。程序代码易于人类编写和理解，但计算机无法直接理解，需要先“翻译”为机器语言才行，编译便是完成这个“翻译”工作的。与此相对，运行便是将机器语言加载到内存中执行的过程。`

### 变量的声明与赋值

在Go语言中，声明变量的一般格式为：

```Go
var name type
```

其中，var是声明变量的关键字，固定不变，表明意图——要声明一个变量；name紧随其后，是开发者自定义的变量名，可根据实际用途和命名规范命名；type表示该变量所属的数据类型。

完成声明后，便要对变量进行赋值了，否则它没有任何意义。赋值后，变量就有了“初始值”；对于已经有值的变量，再次赋值将使用新值覆盖旧值，达到修改的目的。

和大多数编程语言一样，使用等号“=”为变量或常量赋值。如：

```Go
//声明一个名为number的变量，类型为int（整数类型）
var number int
//为number赋值
number = 100
```

如此，number这个变量就表示100这个整数了。此外，变量的声明和赋值还可一并完成，如：

```Go
//变量声明
var number int = 100
```

这种写法与前一个示例作用相同。

### 常量的声明与赋值

常量声明和赋值的一般格式为：

```Go
const name type = value
```

其中，const是声明常量的关键字，固定不变，表明意图，要声明一个常量；name和type的意义与声明变量时一样；value是常量的值。如：

```Go
//声明一个名为PI的常量，类型为float64（浮点数类型）
const PI float64 = 3.14
```

`❗️ 注意： 声明常量时，必须为其赋值，且后续无法修改。`

### Go语言的类型推断

使用Go语言可简化代码，类型推断体现了这一点。当声明与赋值一并进行时，如果数据为Go内置的基础类型，则可无需指定类型。如：

```Go
//变量声明
var number = 100
//常量声明
const PI = 3.14
```

无需担心，由于number的值为100，Go语言会推断出它的类型为整数型。同理，PI也会被推断为浮点数型。

对于变量，还有一种超级精简的声明和赋值方式，示例如下：

```Go
//变量声明
number := 100
```

`❗️ 注意： 冒号等于号“:=”的作用是声明和赋值，若number是已经声明过的变量，则无法使用 := 的方式赋值。`

### 批量声明/赋值

为了方便多个变量/常量的声明和赋值，我们还可以批量处理它们，示例如下：

```Go
//变量
var (
        //声明+赋值
        number int = 100        
        //声明+赋值（类型推断）        
        text = "Hello"        
        //只声明        
        name string)
//常量
const (
        // PI 声明+赋值        
        PI float64 = 3.14        
        // WIDTH 声明+赋值（类型推断）        
        WIDTH  = 5        
        / HEIGHT 声明+赋值（类型推断）        
        HEIGHT= 10
)
```

到此，一些朋友可能会问：什么是常量/变量？为什么常量的值可以修改而变量不行？为何声明常量都用大写字符？除了示例中的int、float64、string，还有哪些内置类型……

带着这些疑问，我们继续往下看。

## 基本数据类型

和其它高级编程语言类似，Go语言同样内置了多种基本数据类型，它们也被称为内置数据类型。

除了基本数据类型之外，还有接口类型（下一讲中会介绍）和复合类型（可以简单地理解为基本数据的“组合体”，如数组、切片、结构体等）。

由此可见，掌握基本数据类型是实现复杂运算乃至构建复杂程序的基础，也是日常开发中使用最频繁的类型。

Go语言的基本数据类型包括数字型（含整数int系列、浮点数float系列和复数complex系列）、布尔型（bool）和字符串型(string)。对于数字型和布尔型较为易懂，在本讲前面的内容中已经使用过了，这里要特别强调字符串型。

对于字符串型值，我们通常在必要时使用一些转义字符，以实现文本的正确输出。

举例来说，如果我们想要使用单个变量表示下面的两行字：

> 汉语:"你好"的英文翻译是:"Hello" 汉语:"早上好"的英文翻译是:"Good Morning"

代码可写为：

```Go
var text string = "汉语:\"你好\"的英文翻译是:\"Hello\"\n汉语:\"早上好\"的英文翻译是:\"Good Morning\""
fmt.Println(text)
```

这段代码中，使用了"输出英文双引号，\n用作换行。当然，若使用中文的双引号时无需使用转义的。更多转义字符及含义请参考附录四。

## 小结

🎉 恭喜，您完成了本次课程的学习！

📌 以下是本次课程的重点内容总结：

1. 变量与常量
    
2. 声明
    
3. 基本数据类型
    
4. 代码风格约定
    

我们使用的几乎所有软件的背后，其实都是数据，数据是构成程序的基础单位。Go语言将数据分为了常量与变量，分别表示不变的数据和可变的数据。程序运行后，数据被放到计算机内存中管理并参与运算。声明在内存中开辟空间，让数据在内存中“安家”。

为了增强代码的可读性和安全性，Go语言本身是静态语言，数据的类型在声明时便要指定。Go语言中的基本数据类型分为数值型、布尔型和字符串型。

为了便于理解和规范代码，为变量命名时，遵循“驼峰式命名法”，再根据可见性使用小驼峰和大驼峰式；为常量命名时，遵循全大写，单词之间使用下划线分割的方式命名。另外，源码文件名、包名等也有规范命名要求。

学习这一讲时，我特别建议大家动手实践，尤其对于编程0基础的同学来说，练习更为重要，切勿停留在理解层面。如果有问题的话，欢迎各位随时在微信群里发问。

➡️ 在下次课程中，我们会阐述如下内容：

- Go语言基础语法之流程控制结构，包括：
    
    - 指针类型
        
    - 运算符及优先级
        
    - 类型转换
        

## 附录一 Go语言中的关键字和保留字

**Go语言中的关键字**

|   |   |
|---|---|
|包管理|**声明与定义**|
|import、package|chan、const、func、interface、map、struct、type、var|

**Go语言中的保留字**

|   |   |
|---|---|
|**常量**|**变量类型**|
|true、false、iota、nil|Int、int8、int16、int32、int64、uint、uint8、uint16、uint32、uint64、uintptr、float32、float64、complex128、complex64、bool、byte、rune、string、error|

## 附录二 Go语言命名规范

Go语言中的命名规则应尽量使用能表达其含义或目的的一个或多个英文单词来命名。英文单词之间的连接方式和大小写规则如下：

### 源码文件名

英文单词全部小写，每个单词之间使用下划线分割。

如：hello_world.go、calc.go

### 包名

使用尽量简短的英文单词，全部小写，名称不要与Go内置标准库相同。

如：net、database

### 变量名

整体遵循驼峰式命名法。允许从外部访问的名字（类似Java中的public修饰符）以大写开头（大驼峰法，亦称帕斯卡命名法），不允许从外部访问的名字以小写开头（小驼峰法）。对于布尔类型的变量，可考虑添加Has、Is、Can、Allow前缀。

如：age、personStatus、StudentAge、isDarkMode

### 常量名

英文单词全部大写，每个单词之间使用下划线分割。对于布尔类型的变量，可考虑添加Has、Is、Can、Allow前缀。

如：SERVER_URL、IS_ALLOW_DOWNLOAD

### 结构体名

整体遵循驼峰式命名法。允许从外部访问的名字（类似Java中的public修饰符）以大写开头（大驼峰法，亦称帕斯卡命名法），不允许从外部访问的名字以小写开头（小驼峰法）。

如：personInfo := {"David", "18"}

使用struct关键字进行声明和初始化时，使用多行表示，每行表示一个成员。

如：

```Go
type PersonInfo struct {
   name string
      age  int
}
```

### 接口名

整体遵循驼峰式命名法。允许从外部访问的名字（类似Java中的public修饰符）以大写开头（大驼峰法，亦称帕斯卡命名法），不允许从外部访问的名字以小写开头（小驼峰法），通常以“er”结尾。

如：

```Go
type DownloadListener interface {
   DownloadStart() (err error)   
   DownloadInProgress() (err error)   
   DownloadComplete() (err error)
   }
```

## 附录三 Go语言基本数据类型定义及精度

### 整数型

|   |   |
|---|---|
|类型|精度|
|uint8|无符号 8 位整型 (0 到 28-1)|
|uint16|无符号 16 位整型 (0 到 216-1)|
|uint32|无符号 32 位整型 (0 到 232-1)|
|uint64|无符号 64 位整型 (0 到 264-1)|
|int8|有符号 8 位整型 (-27 到 27-1)|
|int16|有符号 16 位整型 (-215 到 215-1)|
|int32|有符号 32 位整型 (-231 到 231)|
|int64|有符号 64 位整型 (-264 到 264)|

### 浮点型

|   |   |
|---|---|
|类型|精度|
|float32|±1.18×10-38 到 ±3.4×1038|
|float64|±2.23×10-308 到 ±1.8×10308|

### 复数型

|   |   |
|---|---|
|类型|精度|
|complex64|含 float32 位实数和 float32 位|
|complex128|含 float64 位实数和 float64 位虚数|

### 布尔型

|   |   |
|---|---|
|类型|精度|
|bool|true 或 false|

### 字符串型

|   |   |
|---|---|
|类型|精度|
|string|UTF-8 编码标识的 Unicode 文本|

# 基础语法二｜指针和运算符

本节继续介绍Go语言的基础语法知识，具体包括以下内容：

- 指针类型
    
- 运算符及优先级
    
- 类型转换
    

在上一讲中，我们介绍了Go语言的基本数据类型，学会了如何对变量进行声明和赋值，也知道了在这个过程中会在内存开辟空间方便它们“安家”。那如何才能找到这个“家”呢？这就涉及到了指针。

通过使用指针，开发者可以直接访问内存中的数据，从而可以实现对数据的精准管理以及运算。

如果说变量名是数据的“代号”，那么指针存放的则是数据的“**实际地址**”，我们可以通过这个地址获取或修改存放于这个地址的变量的值。

存放整数值的变量称为整型变量，存放布尔值的变量称为布尔变量……类似地，存放指针值的变量称为指针变量。

那么问题来了，想要获取或改变某个变量的值，直接通过变量名就可以实现了。而且像Java之类的编程语言几乎不会用到指针，**那Go为何还要用指针呢？**

`❗️ 注意： 实际上，Java中的指针操作封装在JDK中，普通开发者一般不会接触到，所以会误认为Java没有指针。`

## 指针类型

我们不妨先了解一下Go语言中的指针，它主要由两大核心概念构成：**类型指针**和**切片指针**。

- 类型指针：在**传递数据**时直接使用指针，可以避免创建数据的副本，节约内存开销。类型指针不能进行偏移和运算，可以**避免非法修改**为其它数据的风险，也更**有利于****垃圾回收**机制及时找到并回收它们；
    
- 切片指针：切片由**指向起始元素的指针**、元素数量和总容量构成。当访问切片发生越界时，会发生宕机并输出堆栈信息。宕机是**可以恢复**的，而崩溃只能导致程序停止运行。
    

可见，**使用指针更有利于程序运行的性能和稳定性**。另外，在某些操作中，如使用反射修改变量的值，必须使用可寻址的变量（通过指针）。

在实际应用中，最为常用的便是获取变量的内存地址，以及获取某个地址对应的值。在Go语言中，前者使用“&”运算符，后者使用“*”运算符。它们互为反向操作，操作的对象也不同。具体请看下面的示例：

```Go
//exampleNumberA变量（整数型变量）声明和赋值
var exampleNumberA int = 10
//获取exampleNumberA的地址，并赋值给exampleNumberAPtr变量（exampleNumberAPtr的类型是指针类型）
exampleNumberAPtr := &exampleNumberA
//输出exampleNumberAPtr变量的值（将输出内存地址）
fmt.Println(exampleNumberAPtr)
//获取exampleNumberAPtr（指针变量）表示的实际数据值，并赋值给exampleNumberAPtrValue变量（整数型变量）
exampleNumberAPtrValue := *exampleNumberAPtr
//输出exampleNumberAPtrValue变量（整数型变量）的值
fmt.Println(exampleNumberAPtrValue)
```

运行后，控制台输出：

> 0xc00001a088 10

`💡 提示： 在练习时，如果内存地址输出与上述结果不符，或者即使是相同的程序，每次运行结果也不同，都是正常现象。因为内存的分配并不是固定的。`

上面的代码示例演示了如何使用已有的变量创建指针类型变量。我们还可以使用new()函数直接创建指针变量，相当于在内存中创建了**没有变量名**的**某种类型**的**变量**。

这样做无需产生新的数据“代号”，取值和赋值转而通过指针变量完成。常用在无需变量名或必须要传递指针变量值的场景中。

new()函数的使用格式如下：

```Go
new(type)
```

其中，type是所在地址存放的数据类型。一旦完成创建，便会在内存中“安家”，完成内存分配，即使没有赋值。

具体代码示例如下：

```Go
//使用new()函数创建名为exampleNumberAPtr指针类型变量，表示int64型值
exampleNumberAPtr := new(int64)
//修改exampleNumberAPtr表示的实际数据值
*exampleNumberAPtr = 100
//获取exampleNumberAPtr表示的实际数据值
fmt.Println(*exampleNumberAPtr)
```

程序运行后，控制台将输出：

> 100

## 运算符与优先级

有了数据，下一步便是使用这些数据进行运算了。Go语言总共提供了6种常用的运算符，分别为算术运算符、关系运算符、逻辑运算符、位运算符、赋值运算符以及指针运算符。我们先从最易懂的算术运算符开始。

`💡 提示： 附录一详细列出了Go语言中所有的运算符及其含义，以及运算符的优先级顺序。各位在学习时应对照参考，尝试每一种运算符的使用。`

#### 算术运算符

算术运算符的意义和使用和数学上的概念很类似，比如：

```Go
var exampleNumA int = 10
var exampleNumB int = 20
var exampleNumC int = 30
var exampleNumD = exampleNumA + exampleNumB*exampleNumC
fmt.Println(exampleNumD)
```

上述代码运行后，控制台输出610。显然，exampleNumD的值就是10+20*30，即610。

需要注意的是，在做除法时，对于int类别结果只保留整数。即使无法整除，余数也会被丢弃。如：

```Go
var exampleNumA int = 10
var exampleNumB int = 3
fmt.Println(exampleNumA / exampleNumB)
```

运行后，控制台的输出为：

> 3

若要获取余数，需要用到取余（%）运算符，请参考下面的代码：

```Go
var exampleNumA int = 10
var exampleNumB int = 3
fmt.Println(exampleNumA / exampleNumB)
fmt.Println(exampleNumA % exampleNumB)
```

运行后，控制台将输出：

> 3 1

上述结果中，3仍然是除法的结果，1是余数。

`❗️ 注意： 和数学中的除法限制一样，0不能作为被除数，否则将引发宕机。当我们误将0作为除数时，GoLand会以波浪线的形式给出警告提示。`

另外，还有一种较为精简的自增（++）和自减（--）运算符，它们相当于加1和减1，然后再将计算结果赋值给自身变量，如：

```Go
var exampleNumA int = 10
//exampleNumA = exampleNumA + 1
exampleNumA++
fmt.Println(exampleNumA)
```

这段代码的运行结果为：

> 11

exampleNumA++与被注释的代码作用相同。

#### 关系运算符

关系运算符则用来判断二者的关系，当结果与判断条件一致时，返回true，反之则返回false。例如：

```Go
var exampleNumA int = 10
var exampleNumB int = 20
fmt.Println(exampleNumA <= exampleNumB)
```

这段代码中，最后一行的 <= 便是关系运算符之一，表示小于或等于。显然，10比20要小，因此这段代码最终将输出：

> true

#### 逻辑运算符

逻辑运算符通常用来将两个条件组合，获得组合后的关系，最终将输出布尔类型值。其组合方式包括与“&&”、或“||”、非“!”。使用示例如下：

```Go
var exampleBoolA bool = true
var exampleBoolB bool = false
//逻辑与运算。当exampleBoolA和exampleBoolB均为true时，结果为true；其他情况均为false。
fmt.Println(exampleBoolA && exampleBoolB)
//逻辑或运算。当exampleBoolA或exampleBoolB有一个为true时，结果为true；当exampleBoolA和exampleBoolB都是false时，结果为false。
fmt.Println(exampleBoolA || exampleBoolB)
//逻辑非运算。将某个布尔类型的值取反。
fmt.Println(!exampleBoolB)
```

程序运行后，控制台将输出：

> false true true

#### 位运算符

位运算符运用在整数型变量，在进行运算时，会首先将其它进制的数值转换为二进制的数值，然后使用二进制数值进行运算，最后以原始进制类型返回计算结果。例如：

```Go
//十进制7转二进制结果为0111
var exampleNumA int = 7
//十进制5转二进制结果为0101
var exampleNumB int = 5
fmt.Println(exampleNumA & exampleNumB)
```

在这段代码中，&就是位运算符中的一个，表示按位与运算。由注释中的内容可知，7和5的按位与运算实际上就是0111和0101的按位与运算。当前后两个数对应位的数字都是1时，计算结果对应位的数字为1，否则为0。具体请看下图：

![](https://internal-api-space.feishu.cn/space/api/box/stream/download/asynccode/?code=YjgyODE0YmIyZThjMjJhNTcwNzU1MmUxMWFkZWE3ODlfWG5Ga21jc25KRlpjaXNDRzJSWG5PT3ZtT1BlMTdlcHVfVG9rZW46TlRXQWJIaXF5b2xwV1N4eUZQSmNzdU5IbmdEXzE2OTIzMDI4MjU6MTY5MjMwNjQyNV9WNA)

#### 赋值运算符

赋值运算符其实我们一直都在用，在为某个变量赋初值时使用的“=”便是最为简单的赋值运算符了。此外，还有一些更为简便的经过运算的赋值运算符，如：

```Go
var exampleNumA int = 10
//exampleNumA = exampleNumA + 20
exampleNumA += 20
fmt.Println(exampleNumA)
```

在这段代码中，exampleNumA += 20与被注释掉的语句含义相同。

#### 指针运算符

指针运算符包含 & 和 * 两个运算符，已经在本讲前面的“指针类型”介绍过了，有疑惑的朋友请学习“指针类型”部分。

`❗️ 注意： 请大家结合本讲最后附录一的内容，亲自动手尝试每一种运算符的使用。`

#### 运算符的优先级

在实际开发中，通常会处理较为复杂的运算，通常会将多个变量与多种运算符一齐使用，如此便不可避免地出现先后次序地问题。

**对于****算术运算符****，遵循数学上的运算顺序。** 比如在既有乘法又有加法的情况下，会先进行乘法运算，再进行加法运算。当然，如果我们希望先进行加法运算，可以使用成对的小括号将加法部分包裹起来。这些做法在Go语言中也是相同的。

完整的运算符优先级顺序请参考文末附录一的相关内容。

`💡 提示： 成对的小括号在Go语言中优先级最高，且可以嵌套使用。在日后的开发中，当不太明确运算符的优先级时，最为稳妥的方法就是加小括号来限定计算顺序。`

## 类型转换

在某些特定的场景下，我们需要对数据进行类型转换才能继续后面的逻辑（如某个函数需要float64类型参数，需要将现有int64类型值传入其中时）。**在Go语言中，进行类型转换有两个要注意的地方**，分别是：

1. 只能进行相同类别的转换，如将int32转换为int64。不同类别的转换将引发编译时错误，如将bool转换为string；
    
2. 若将取值范围较大的类型转换为取值范围较小的类型，且实际值超过取值范围较小的类型时，将发生精度丢失的情况。
    

有关不同类型的取值范围，请参考[上一讲](https://juejin.cn/book/7039174186522116131/section/7047596606715068430)的附录三。

举例来说，下面的代码实现了将float32类型值转换为float64与int32类型值：

```Go
//声明float32型变量exampleFloat32并赋值
var exampleFloat32 float32 = 150.25
//将exampleFloat32转换为float64类型，并将结果赋值给exampleFloat64
exampleFloat64 := float64(exampleFloat32)
//输出exampleFloat64的类型和值
fmt.Println(reflect.TypeOf(exampleFloat64), exampleFloat64)
//将exampleFloat32转换为int32类型，exampleInt32
exampleInt32 := int32(exampleFloat32)
//输出exampleInt32的类型和值
fmt.Println(reflect.TypeOf(exampleInt32), exampleInt32)
```

运行后，控制台如下输出：

> float64 150.25 int32 150

显然，由于float64比float32的取值范围更广，因此转换后不会损失精度；由于int32不包含小数位，因此原值的.25部分被丢弃。

``💡 提示： reflect.TypeOf()是使用反射获取变量类型的函数；fmt.Print`ln`()函数支持同时输出多个值，每个值之间使用英文的逗号（,）隔开。``

## 小结

🎉 恭喜，您完成了本次课程的学习！

📌 以下是本次课程的重点内容总结：

1. 指针类型
    
2. 运算符及优先级
    
3. 类型转换
    

借助指针，我们可以轻松且精准地直接访问和修改内存中的数据，还学会了使用new()函数创建“匿名”的变量。虽然现在看上去并没有什么具体的使用场景，在后面的数组、切片等内容中，便能体会到指针的妙用了。

有了数据，下一步便是数据的运算了。本讲介绍了Go语言中的常用运算符及它们的结合顺序（优先级），在实际开发中使用很常用。

最后，在向某些函数传递数据时，需要按照参数列表的要求传入正确的类型。此时，借助类型转换，可以将数据类型转换为所要求的类型。当然，要充分考虑数据精度丢失的风险。

学习这一讲时，我特别建议大家动手实践，尤其对于编程0基础的同学来说，练习更为重要，切勿停留在理解层面。如果有问题的话，欢迎各位随时在微信群里发问。

➡️ 在下次课程中，我们会阐述如下内容：

- Go语言基础语法之流程控制结构，包括：
    
    - 循环结构
        
    - 流程控制语句
        
    - 条件分支结构
        

## 附录一 Go语言中的运算符、含义及优先级

### 算术运算符

|   |   |
|---|---|
|算数运算符|含义|
|+|相加|
|-|相减|
|*|相乘|
|/|相除|
|%|求余数|
|++|自增1|
|--|自减1|

### 关系运算符

|   |   |
|---|---|
|关系运算符|含义|
|==|相等|
|!=|不相等|
|<|小于|
|<=|小于或等于|
|>|大于|
|> =|大于或等于|

### 逻辑运算符

|   |   |
|---|---|
|**逻辑运算符**|**含义**|
|&&|逻辑与（AND），当运算符前后两个条件均为true时，运算结果为true|
|\||逻辑或（OR），当运算符前后两个条件其中有一个为true时，运算结果为true|
|!|逻辑非（NOT），对运算符后面的条件结果取反，当条件结果为true时，整体运算结果为false；反之则为true。|

### 位运算符

|   |   |
|---|---|
|位运算符|**含义**|
|&|按位与（AND）操作，其结果是运算符前后的两数各对应的二进位相与后的结果。|
|\||按位或（OR）操作，其结果是运算符前后的两数各对应的二进位相或后的结果。|
|按位异或（XOR）操作，当运算符前后的两数各对应的二进位相等时，返回0；反之，返回1。|
|&^|按位清空（AND NOT）操作，当运算符右侧某位为1时，运算结果中的相应位值为0；反之，则为运算符左侧相应位的值。|
|<<|按位左移操作，该操作本质上是将某个数值乘以2的n次方，n即为左移位数。更直观地来看，其结果就是将某个数值的二进制每个位向左移了n个位置。超限的高位丢弃，低位补0。|
|>>|按位右移操作，该操作本质上是将某个数值除以2的n次方，n即为左移位数。更直观地来看，其结果就是将某个数值的二进制每个位向右移了n个位置。超限的低位丢弃，高位补0。|

### 赋值运算符

|   |   |
|---|---|
|**赋值运算符**|**含义**|
|=|直接将运算符后面的值赋给左侧。|
|+=|先将运算符左侧的值与右侧的值相加，再将相加和赋给左侧。|
|-=|先将运算符左侧的值与右侧的值相减，再将相减差赋给左侧。|
|*=|先将运算符左侧的值与右侧的值相乘，再将相乘结果赋给左侧。|
|/=|先将运算符左侧的值与右侧的值相除，再将相除结果赋给左侧。|
|%=|先将运算符左侧的值与右侧的值相除取余数，再将余数赋给左侧。|
|<<=|先将运算符左侧的值按位左移右侧数值个位置，再将位移后的结果赋给左侧。|
|>>=|先将运算符左侧的值按位右移右侧数值个位置，再将位移后的结果赋给左侧。|
|&=|先将运算符左侧的值与右侧的值按位与，再将位运算后的结果赋给左侧。|
|^=|先将运算符左侧的值与右侧的值按位异或，再将位运算后的结果赋给左侧。|
|\|=|先将运算符左侧的值与右侧的值按位或，再将位运算后的结果赋给左侧。|

### 指针运算符

|   |   |
|---|---|
|**指针运算符**|含义|
|&|获取某个变量在内存中的实际地址|
|*|用于声明一个指针变量|

### 运算符优先级

|   |   |
|---|---|
|优先级|运算符|
|1|,|
|2|=、+=、-=、*=、/=、 %=、 >=、 <<=、&=、^=、\|=|
|3|\||
|4|&&|
|5|\||
|6|
|7|&|
|8|==、!=|
|9|<、<=、>、>=|
|10|<<、>>|
|11|+、-|
|12|*（乘号）、/、%|
|13|!、*（指针）、& 、++、--、+（正号）、-（负号）|
|14|( )、[ ]、->|

上表中，优先级值越大，优先级越高。

# 流程控制｜使用循环结构等完成重复性工作

本节介绍Go语言中的程序流程控制结构，具体包括以下内容：

1. 循环结构
    
2. 流程控制语句
    
3. 条件分支结构
    

经过前面两个小节的学习，我们初步掌握了Go语言的语法知识。本小节将介绍循环和条件分支，从而使用少量代码完成大量重复性的操作，就像标准化作业一样。为了便于理解，本小节将使用3个示例来讲述具体的知识点。

## 循环结构

先来看这样一段输出：

![](https://internal-api-space.feishu.cn/space/api/box/stream/download/asynccode/?code=MWM0YzVlYWFiOThhNTA2YmY0ZWVjNWEzZTBlZjhiZGJfSWU1UktQd1ZNNzRTNTRCWVVtaFh2ZkdMOUh4NHVNaUNfVG9rZW46WkNEYWJ5aTRzb3pCWFl4YXZ4ZmNYMk1lbmpiXzE2OTIzMDI4MjU6MTY5MjMwNjQyNV9WNA)

可以看到，这是个由星号 * 组成的实心菱形，总共有13行。如何实现这样的效果呢？该不会是手写13行输出语句吧？当然不是！

`💡 提示： 在实际开发中，产品的需求千变万化。面对复杂的功能，通常的做法是“拆分”。即把一个复杂的需求分解为多个简单的需求，然后逐个实现。`

仔细观察上图中的输出内容可以发现，其实：

- 菱形就是由若干行（总共13行）组成的；
    
- 菱形是上下轴对称图形，以第7行为轴。
    

将菱形拆分为上下两个三角形，可以发现：

- 每行都是由若干空格和若干星号构成；
    
- 对于上半部分（i从1开始）：
    
    - 第i行的星号数是2*i-1个；
        
    - 第i行的空格数是7-i个。
        
- 对于下半部分（i从1开始）：
    
    - 第i行的空格数是i个；
        
    - 第i行的星号数是2*7-1-(i*2)个。
        

到此，我们不仅做完了拆分，还摸透了规律。接下来，只要按规律编写代码即可。在Go语言中，像这种重复地执行相似逻辑，可以使用循环结构实现。循环结构的格式如下：

```Go
for init; condition; post {
    //循环体代码块
}
```

其中，for表明接下来的代码是for循环结构；init是初始化语句；condition是关系或逻辑表达式，值为true时则会停止循环；post是每次循环结束后执行的语句；循环体代码块就是要重复执行的代码了。

接下来，我们用这个循环结构实现上半部分的三角形：

```Go
func main() {
   n := 7
   for i := 1; i <= n; i++ {
      for j := 0; j < n-i; j++ {
         fmt.Print(" ")
      }
      for k := 0; k < 2*i-1; k++ {
         fmt.Print("*")
      }
      fmt.Println()
   }
}
```

执行结果为：

![](https://internal-api-space.feishu.cn/space/api/box/stream/download/asynccode/?code=ZjdmYTNkNjJiZDRkZGQ3MjBiNjhmYjg2ZDBjZDkwZDhfT1VWUGFJVFVqYmlDMU1wM0M3UEFObnBhanNVYkkwUmpfVG9rZW46RVZUQ2JzdDR0b3djVW54RFFLUGNNcXF4bjFjXzE2OTIzMDI4MjU6MTY5MjMwNjQyNV9WNA)

我们逐行理解上述代码。

1. 声明变量n，并赋初值为7，表示上半部分由7行构成（包含对称轴）。
    
2. 接下来是for循环结构，**初始化条件是变量i为1**，i表示总行数；判断**退出循环的条件是变量i小于或等于n**，即输出7行后退出；每次循环即完成单行输出，因此在**循环后i自增1**。如此，便构成了总共循环7次的for循环结构。
    
3. 在for循环内部，有两个for循环，分别用于**输出空格**和**星号**，另外在两个循环执行完毕后，输出了**换行**，用于折行。
    
4. 用于输出空格的for循环结构，**初始化条件是变量j为0**，j表示输出的空格数；判断**退出循环的条件是变量j小于n-i**，即总共输出n-i个空格；每次循环完成所有空格的输出，因此**循环后j自增1**。如此，便实现了单行空格的输出。
    
5. 用于输出星号的for循环结构，**初始化条件是变量k为0**，k表示输出的星号数；判断**退出循环的条件是变量k小于2*i-1**，即总共输出2*i-1个星号；每次循环完成所有星号的输出，因此**循环后k自增1**。如此，便实现了单行星号的输出。
    

好了，如果各位理解了上半部分的实现原理，不妨亲自动手尝试实现下半部分。

`❗️ 注意： 使用循环时，务必确保有明确的可退出循环的条件，否则程序将陷入死循环，无法终止。在开发时，若不慎执行了死循环，可点击GoLand工具栏中的“Stop”按钮（接近红色，有点像音乐播放器的停止播放按钮）强行停止。`

输出菱形的完整代码如下：

```Go
func main() {
    n := 7
    for i := 1; i <= n; i++ {
        for j := 0; j < n-i; j++ {
                fmt.Print(" ")
        }
        for k := 0; k < 2*i-1; k++ {
                fmt.Print("*")
        }
        fmt.Println()
    }
    for i := 1; i < n; i++ {
        for j := 0; j < i; j++ {
            fmt.Print(" ")
        }
        for k := 0; k < 2*n-1-2*i; k++ {
            fmt.Print("*")
        }
            fmt.Println()
    }
}
```

## 条件分支结构

接下来，输出菱形的题目要“升级了”！

单纯地输出菱形未免太单调了些，我们希望通过不同的文字来输出不同的样式。当文字为“上”的时候，输出上半截7行三角形；当文字为“下”时，输出下半截6行三角形；当文字为“全”是，输出13行菱形。

显然，这个题目升级需要进行“条件判断”，不同的条件执行不同的逻辑。如果Go语言能有“如果……那么……”这种结构就好了！Go语言恰恰有这种结构——条件分支。

Go语言中的条件分支结构如下：

```Go
if condition {
    //条件成立时要执行的语句
}else{
    //条件不成立时要执行的语句
}
```

其中，condition是关系或逻辑表达式。另外，如无必要，else是可以省略的：

```Go
if condition {
    //条件成立时要执行的语句
}
```

如有必要，还可追加更多的判断条件：

```Go
if condition1 {
    //条件condition1成立时要执行的语句
}else if condition2 {
    //条件condition2成立时要执行的语句
}else if condition3 {
    //条件condition3成立时要执行的语句
}else{
    //以上三种条件都不成立时要执行的语句
}
```

如此，解答“升级”后的题目就容易多了。参考条件分支的结构，思路如下：

```Go
if 文字是“上”或“全”{
    输出菱形前7行
}
if 文字是“下”或“全”{
    输出菱形后6行
}
```

之前我们已经完成了输出菱形，只需将新的代码逻辑与之结合即可，完整代码如下：

```Go
func main() {
   outputMode := "全"

   n := 7
   if outputMode == "上" || outputMode == "全" {
      for i := 1; i <= n; i++ {
         for j := 0; j < n-i; j++ {
            fmt.Print(" ")
         }
         for k := 0; k < 2*i-1; k++ {
            fmt.Print("*")
         }
         fmt.Println()
      }
   }
   if outputMode == "下" || outputMode == "全" {
      for i := 1; i < n; i++ {
         for j := 0; j < i; j++ {
            fmt.Print(" ")
         }
         for k := 0; k < 2*n-1-2*i; k++ {
            fmt.Print("*")
         }
         fmt.Println()
      }
   }
}
```

我们可以通过改变outputMode的值来控制输出的文字形状。

## 流程控制语句

流程控制语句多用于管理循环结构的运行。考虑这样一个需求：编程实现查找1-10以内的素数。

`💡 提示： 素数又称质数，是指在大于1的自然数中，除了1和它本身以外不能被其它整数整除的自然数，2是最小的素数。`

这一次，我们需要在已有的代码上增加，但不改变原有的代码。先来看看现有代码：

```Go
func main() {
    for i := 2; i > 0; i++ {
        if i == 2 {
            fmt.Println(i)
        }
        //假定i为素数
        flag := true
        for j := 2; j < i; j++ {
            if i%j == 0 {
                //当i能被某个整数整除时，不是素数
                flag = false
            }
        }
        //如果依旧为true，则i为素数
        if flag {
            fmt.Println(i)
        }
    }
}
```

通过阅读上述代码可以发现：

- 代码整体由一个for循环构成，初始化语句声明了变量i，从2开始（2是最小的素数），循环结束的条件是i大于0，每次循环结束后i自增1；
    
- 循环体内，首先判断了i是否等于2，如果是的话直接输出了i的值；
    
- 然后，声明了布尔类型变量flag，表明是否为素数，用于后续判断是否输出i的值；
    
- 接下来，使用循环结构判断i是否为素数。初始化时声明了变量j，从2开始，跳出循环的条件时j小于i，判断i是否为素数只需从2开始尝试做除法，直到i-1为止。若余数为0，则表示能被整除，此时，flag应改为false。每次循环结束后j自增1；
    
- 最后，判断flag的值，若flag为true，则表示i是素数，输出i，反之则不是素数。
    

代码运行后，控制台输出：

> 2 2 3 5 7 11 13 ...

明明是查找10以内的素数，为何不停地输出这么多结果呢？请大家来找茬，看看这段代码中有哪些问题？

1. 最外层的for循环，终止条件是i大于0，但i始终是大于0的，程序一旦开始，便无法结束，陷入死循环；
    
2. 当i等于2时，输出了一次i的值。然而在内层的循环体中，还将再次输出。最终将输出两次2；
    
3. 在内层循环中，一旦i与j取余结果为0，则表明i不是素数，内层for循环结构无需再执行剩下的循环了。
    

解决了这3个问题，便能实现查找1-10以内的素数的需求了。要解决它们，就需要请出Go语言中的流程控制语句来“救场”了。在Go语言中，较为常用的流程控制语句有**continue**和**break**。前者的意义是立即结束本次循环，执行下一个循环；后者的意义是终止循环。

显然，解决问题1和3，只需使用break语句打断相应循环的执行即可；解决问题2，只需使用continue语句提前终止本次循环，直接执行下一次循环即可。因此，将代码改为：

```Go
func main() {
    for i := 2; i > 0; i++ {
        //当i大于10s
        if i > 10 {
            break
        }
        if i == 2 {
            fmt.Println(i)
            continue
        }
        //假定i为素数
        flag := true
        for j := 2; j < i; j++ {
            if i%j == 0 {
                //当i能被某个整数整除时，不是素数
                flag = false
                break
            }
        }
        //如果依旧为true，则i为素数
        if flag {
            fmt.Println(i)
        }
    }
}
```

运行结果为：

> 2 3 5 7

## 小结

🎉 恭喜，您完成了本次课程的学习！

📌 以下是本次课程的重点内容总结：

1. 循环结构
    
2. 流程控制语句
    
3. 条件分支结构
    

在实际开发中，代码流程控制可以帮助我们使用较少的代码完成大量重复性的工作。除了本讲中提及的常用流程控制结构外，还有用于条件分支的[Switch...case...结构](https://link.juejin.cn/?target=http%3A%2F%2Fc.biancheng.net%2Fview%2F48.html)、用于流程控制的[goto语句](https://link.juejin.cn/?target=http%3A%2F%2Fc.biancheng.net%2Fview%2F49.html)，感兴趣的朋友可以当作扩展阅读。

➡️ 在下次课程中，我会介绍如下内容：

- Go语言中的数组、切片和集合的声明和赋值
    

# 数组、切片和集合 一｜管理一组数据

在上一讲的末尾，我们使用循环结构实现了查找10以内的素数。但这并不意味着结束，因为查找往往意味着使用。而要保存和访问找出的这一组数据，就需要使用数组了。

这节课，我们就来介绍一下Go语言中的数据“容器”。本节包括以下内容：

1. Go语言中的数组、切片的声明和赋值
    
2. 集合的声明和赋值
    

## 数组

我们先来回顾查找10以内素数的代码实现：

```Go
func main() {
   for i := 2; i < 10; i++ {
      //假定i为素数
      flag := true
      for j := 2; j < i; j++ {
         if i%j == 0 {
            //当i能被某个整数整除时，不是素数
            flag = false
         }
      }
      //如果依旧为true，则i为素数
      if flag {
         //输出素数i
         fmt.Println(i)
      }
   }
}
```

运行后，控制台输出：

> 2 3 5 7

显然，上述代码中当flag为true时输出的单个i值均为素数，总共有4个。为了方便在后续的代码中使用这4个数，我们将其放置在一个数据“组合”中。像这样的数据“组合”，可以使用数组来管理，数组中的每个值又称为数组中的“元素”。

`❗️ 注意： 数组中的元素并不限制值的类型，但要求所有元素均为相同的类型。`

对于本例而言，便可声明一个总共有4个元素的数组来管理素数结果。Go语言中声明数组的一般格式为：

```Go
var array_name [quantity]Type
```

其中，var关键字用于声明变量；array_name表示数组名；quantity表示数组元素个数；Type表示元素类型。

因此，对于本例，便可声明名为“resultArray”的数组变量，其元素个数为4，类型为int，代码为：

```Go
var resultArray [4]int
```

声明后即可为单个元素赋值了。和其它的编程语言类似，要为数组中的某个元素赋值，格式为：

```Go
array_name[index] = Value
```

其中，array_name表示已声明的数组名；index表示数组中的第N个元素，称之为索引或下标，通常是包含0的正整数；Value则表示具体的数据值。

对于本例而言，若要为数组中的第3个元素赋值为5，对应的代码为：

```Go
resultArray[2] = 5
```

`❗️ 注意： 数组的索引从0开始，因此索引的取值范围应该是从0至数组元素个数减1为止。如本例则为0、1、2、3。超出范围的赋值和取值将引发下标越界错误，导致程序出错。对某一索引位置的元素重复赋值将导致旧值被新值替换。`

到此，数组的声明和赋值方法都有了，下面就来将它们结合到原有代码中吧！

```Go
func main() {
   var resultArray [4]int
   var arrayIndex int = 0
   for i := 2; i < 10; i++ {
      //假定i为素数
      flag := true
      for j := 2; j < i; j++ {
         if i%j == 0 {
            //当i能被某个整数整除时，不是素数
            flag = false
         }
      }
      //如果依旧为true，则i为素数
      if flag {
         //将素数存放到resultArray数组中
         resultArray[arrayIndex] = i
         arrayIndex++
      }
   }
   fmt.Println(resultArray)
}
```

如上代码所示，除了声明resultArray外，还声明了arrayIndex作为数组赋值时的索引之用。每次赋值结束后arrayIndex都会自增1，以便为下个元素赋值。

运行这段代码，控制台输出：

> [2 3 5 7]

如此，查找到的结果集便保存到了resultArray数组中，后面的代码便通过resultArray随时访问结果集了。

接下来思考一个问题，本例要求查找了10以内的素数。如果换成查找30以内、50以内，甚至更大范围的话，查找到的结果必然会有不同程度的增加。

如果使用数组来存放结果的话，很容易引发下标越界错误。和数组相对，Go语言还提供了一种专门存放**不定元素个数**的数据结构——切片。

## 切片

对于已经熟悉数组声明和赋值的朋友来说，使用切片并非难事。在Go语言中，切片的声明一般格式为：

```Go
var slice_name []Type
```

其中，var关键字用于声明变量；slice_name表示切片名；Type表示元素类型。

`💡 提示： 注意到了吗？声明切片和数组的区别仅仅是去掉了中括号中的元素个数！`

对于本例，代码实现为：

```Go
var resultSlice []int
```

`❗️ 注意： 和数组类似，切片中的元素也不限制值的类型，但要求所有元素均为相同的类型。`

完成切片的声明后，就来到赋值环节。

与数组不同，为切片赋值可以理解为“**扩充**”。在一开始，切片里面的元素个数为0。“扩充”一个值，就相当于为切片中的第一个元素赋值。赋值后，切片的元素个数就变成了1。若再次“扩充”，则相当于为切片中的第二个元素赋值。赋值后，切片的元素个数就变成了2，以此类推……

在Go语言中，为切片“扩充”需要使用append()函数，使用格式如下：

```Go
slice_name = append(slice_name, value)
```

其中，slice_name表示已声明的切片变量名，value表示具体的数据值。

值得一提的是，**append()函数本身并不会改变原有切片**，只是将切片“扩容”后的结果作为函数返回值。因此，需要将“扩容”后的结果再次（即函数返回值）赋值给slice_name，才能真正使slice_name发生改变。

对于本例而言，若要“扩充”切片，添加值为2的元素，代码实现为：

```Go
resultSlice = append(resultSlice, value)
```

到此，我们掌握了切片的声明和赋值方法，接下来又到了修改原有代码的时候。修改后的代码如下：

```Go
func main() {
   var resultSlice []int
   for i := 2; i < 30; i++ {
      //假定i为素数
      flag := true
      for j := 2; j < i; j++ {
         if i%j == 0 {
            //当i能被某个整数整除时，不是素数
            flag = false
         }
      }
      //如果依旧为true，则i为素数
      if flag {
         //将素数存放到resultArray数组中
         resultSlice = append(resultSlice, i)
      }
   }
   fmt.Println(resultSlice)
}
```

显然，由于切片在赋值时无需关注下标，因此连原有的arrayIndex变量也省了。

运行这段代码，控制台将输出：

> [2 3 5 7 11 13 17 19 23 29]

接下来，如果想查找100以内的素数，该如何修改呢？答案是——只需要修改循环终止的条件即可（即将i < 30改为i < 100），是不是更方便呢？

在实际项目中，切片的使用其实更为广泛。例如：当用户发起搜索，搜索的结果个数往往会根据搜索关键字的不同而发生变化。在不确定总数的前提下，使用数组显然是不合适的。

## 集合

使用数组不合适，那使用什么呢？答案是：集合。我们考虑另一个场景——管理学生信息。

如何保存和查找一所学校所有学生的信息呢？通过姓名显然是不合适的，因为会有重名的情况。通过年级+姓名呢？显然也是不合适的，因为这可能会执行两次筛选，而且也无法从根本上排除重名的情况。所以，我们应使用一个能标识一个学生**唯一性**的数据作为保存和查找的依据。比如：学号。

一个学号对应一个学生，保存时如此，查找时亦如此。

`💡 提示： 与此类似的管理方式还有身份证号、驾驶证号、商品ID、图书ISBN等等。这些能标识唯一性的值可以统称为“唯一ID”。在实际项目中，为了保证单条数据的唯一性，为其构建唯一ID号是非常有必要的。`

像上述这种唯一ID对应单条数据，可以使用集合来管理。集合可以看作是一类特殊的切片，只不过集合的元素都是由若干“**键-值对**”数据构成的。所谓“键”，相当于“唯一ID”；“值”，相当于单条数据，**键不允许重复**。

Go语言中声明集合的一般格式为：

```Go
var map_name = make(map[key_type]value_type)
```

`❗️ 注意： 和数组、切片类似，集合中的键和值均不限制数据类型，且键和值可分别使用不同的类型。但要求所有键均为相同的类型，所有值均为相同类型。`

其中，var用于声明变量；map_name表示集合的变量名；key_type表示键的类型；value_type表示值的类型。

对于本例而言，学号和学生信息都使用string类型来表示，集合的变量名为studentInfos。对应的代码为：

```Go
var studentInfos = make(map[string]string)
```

集合中元素的赋值和数组类似，只不过中括号中不再是索引，而是键的值。例如，保存学号为“0001”的学生，名为“王小红”，代码实现为：

```Go
studentInfos["0001"] = "王小红"
```

以此类推，继续增加4条信息，完整的代码如下：

```Go
func main() {
   var studentInfos = make(map[string]string)
   studentInfos["0001"] = "王小红"
   studentInfos["0002"] = "李小明"
   studentInfos["0003"] = "张三丰"
   studentInfos["0004"] = "孙小贝"
   studentInfos["0005"] = "何明明"
   // 输出语句
   fmt.Println(studentInfos)
}
```

程序运行结果为：

> map[0001:王小红 0002:李小明 0003:张三丰 0004:孙小贝 0005:何明明]

值得一提的是，若对一个已经存在数据的“键”再次赋值，原有的数据将被**覆盖**。比如，在本例输出语句前添加：

```Go
studentInfos["0003"] = "周丹"
```

再次运行本例，结果则变为：

> map[0001:王小红 0002:李小明 0003:周丹 0004:孙小贝 0005:何明明]

在实际项目中，充分利用集合键唯一的性质，还可以确保**排除重复**的数据。

## 小结

🎉 恭喜，您完成了本次课程的学习！

📌 以下是本次课程的重点内容总结：

1. Go语言中的数组、切片；
    
2. Go语言中集合的声明和赋值。
    

数组、切片和集合都是Go语言中的数据“容器”。使用它们可以将多个数据成组保存，以备后用。

数组是固定长度的，切片是不定长度的。集合是一类特殊的切片，元素由若干键-值对构成，键不允许重复。

在本讲中，无论是数组、切片抑或是集合，获取元素的方式都是一股脑输出的。有没有办法只获取其中某个元素呢？另外，如何获取它们所拥有的元素个数呢？这些问题，我们将在下一讲中一一解答。

➡️ 在下次课程中，我们会介绍如下内容：

- Go语言中的数据“容器”，包括：
    
    - 数组、切片和集合的元素遍历、访问和修改
        

# 数组、切片和集合 二 ｜ 探索一组数据

上一讲我们介绍了Go语言中的容器，即数组、切片和集合变量，并掌握了它们各自的声明和赋值技巧。我们都知道，为某个变量赋值，最终是为了使用它。那么，这一节我们会继续深入，介绍如下内容：

1. 获取数组、切片和集合的元素个数
    
2. 获取和修改数组、切片和集合的元素的值
    
3. 数组、切片和集合的循环遍历
    

## 获取元素个数

相信朋友们还记得那个查找素数的例子，在上一讲中我们实现了查找范围是10以内的素数。现在要求变了，需要查找1000以内素数的个数。

为了方便阅读，我把上一讲中的代码示例搬了过来：

```Go
func main() {
   var resultSlice []int
   for i := 2; i < 10; i++ {
      //假定i为素数
      flag := true
      for j := 2; j < i; j++ {
         if i%j == 0 {
            //当i能被某个整数整除时，不是素数
            flag = false
         }
      }
      //如果依旧为true，则i为素数
      if flag {
         //将素数存放到resultArray数组中
         resultSlice = append(resultSlice, i)
      }
   }
   fmt.Println(resultSlice)
}
```

本例使用了切片而非数组或集合，为什么这样做呢？

因为我们不清楚容器内到底有多少个元素，因此数组不合适。查找到的结果是若干正整数，无需“键-值对”这样的数据结构，因此集合也不合适。

若要改变查找范围为1000以内，只需要修改最外层for循环的终止条件：将i < 10改为i < 1000即可。但运行后发现，输出实在是太多了。10以内的素数仅有4个，看一眼便可得出结论。但1000以内的话，简直无法数得清。

幸好Go语言内置了获取容器内元素个数的函数，这个函数**对数组、切片和集合都有效，且用法相同**，调用格式为：

```Go
len(variable)
```

其中，len()表示调用函数，是固定写法；variable被称为“参数”，表示向函数中“传递”的变量；调用后，函数将返回元素个数，返回值的类型是int。

`💡 提示： 有关函数的更多内容，将在下一讲中详述，这里仅需做到了解、会用即可。`

对于本例而言，获取素数个数只需编写如下代码即可实现：

```Go
fmt.Println(len(resultSlice))
```

下面，将这句代码添加到原有代码中，再次运行程序即可看到控制台上输出元素个数了。

在实际工作中，对于函数的调用是很常见的做法。通过本例能体会到，作为函数的调用者，**无需关注函数内部**是如何实现的（如本例中统计容器内元素个数的具体实现）。这一机制极大降低了重复功能的代码量，还能在一定程度上降低Bug的数量。

但劣势也很明显，当我们不清楚函数在做什么时，就没有信心调用它了。此时，可以通过**函数名**（如本例的len()函数，对应英文单词的length，表示容器的长度，也就是容器内元素的个数）、阅读**函数注释**等方法来了解（回忆一下曾经讲过的“**代码规范**”，在[第5讲 附录二](https://juejin.cn/book/7039174186522116131/section/7047596606715068430)）。

此外，对于陌生的函数，还可以在已知结果的前提下进行初步验证。对于本例而言，就可以先保持“查找10以内的素数”这一条件不变。然后调用len()函数获取resultSlice切片变量的元素个数，看看是不是4。如此，便可初步验证len()函数的作用和正确性了。

当然，这样的验证做得越多，结果越可信。这种“验证”的思路还可用于代码测试，鉴于小册的内容结构，这部分暂不展开详述，在后续的章节中再做介绍。

## 获取/修改元素的值

有些时候，我们还需要获取和/或修改某个特定元素的值。我们还是用查找素数作为例子，这次的要求是逐个输出10以内整数是否为素数。结果如下：

> 0 false 1 false 2 true 3 true 4 false 5 true 6 false 7 true 8 false 9 false 10 false

可以看到，第3、4、6、8个元素（索引值为2、3、5、7）的值为true，它们都是素数，其它元素值为false，不是素数。请大家想想看，如何实现呢？

为了讲解元素值的修改方法，在此给各位提供一个实现思路，一共分为三个步骤：

1. 声明元素个数为11，值类型为bool的数组。并附所有元素初值为false，假定所有元素皆非素数；
    
2. 判断2-10范围内的素数，若是素数，将数组相应索引表示的值改为true；
    
3. 输出数组元素的索引和索引表示的值。
    

接下来实现上面三个步骤。

声明并赋初值是上一讲的内容，使用for循环实现：

```Go
// 声明元素类型为bool的数组。索引表示正整数；值表示是否为素数，true为是。
var resultArray [11]bool
// 赋初值，皆为false
for i := 0; i < 11; i++ {
   resultArray[i] = false
}
```

接着，修改查找素数的逻辑如下：

```Go
// 素数判定
for i := 2; i < 10; i++ {
   //假定i为素数
   flag := true
   for j := 2; j < i; j++ {
      if i%j == 0 {
         //当i能被某个整数整除时，不是素数
         flag = false
      }
   }
   //如果依旧为true，则i为素数
   if flag {
      resultArray[i] = true
   }
}
```

由于0和1不是素数，因此无需理会，循环依旧从2开始。当查找到素数时，将resultArray数组中相应索引所表示的值改为true。如：2是素数，resultArray[2]的值将被改为true。

最后，使用循环依次输出resultArray的索引和索引表示的值：

```Go
for i := 0; i < 11; i++ {
   fmt.Println(i, resultArray[i])
}
```

将上述三个步骤依次结合起来，并运行程序，最终将得到所要求的输出结果。

在实现的过程中不难发现，访问数组中元素时，代码为：resultArray[i]；修改数组中元素的值实际和赋值相同。

由此我们归纳出如下规律：

- **修改数组、切片和集合中的值，方法与赋值相同**；
    
- **获取数组或切片的值，格式为variable[index]**。variable表示数组或切片的变量名；index表示索引值。
    
- **获取集合的值，格式为variable[key_value]**。variable表示集合的变量名；key_value表示键的值。
    

## 循环遍历

在上一个例子中，我们使用了for循环实现了resultArray数组的赋值和输出。

对于数组和切片而言，使用for循环是实现遍历的途径之一，但往往无法适用于集合。

对于数组和切片而言，索引是从0开始的整数，可以使用索引作为循环条件。但集合的的取值方式是通过“键”，而键的值就不一定是数字了。非数字的键，往往会是字符串。

`❗️ 注意： 数组和切片是有序存储的，因此可用索引来循环；集合是无序的，在使用时要格外小心。`

我们还是回顾上一讲中使用过的集合示例：

```Go
func main() {
   var studentInfos = make(map[string]string)
   studentInfos["0001"] = "王小红"
   studentInfos["0002"] = "李小明"
   studentInfos["0003"] = "张三丰"
   studentInfos["0004"] = "孙小贝"
   studentInfos["0005"] = "何明明"
   // 输出语句
   fmt.Println(studentInfos)
}
```

运行后，控制台会一口气依次输出所有studentInfos集合的键值对，如下所示：

> map[0001:王小红 0002:李小明 0003:张三丰 0004:孙小贝 0005:何明明]

现在，需要输出更易于使用者理解的格式，具体如下：

> 学号： 0004 姓名： 孙小贝 学号： 0005 姓名： 何明明 学号： 0001 姓名： 王小红 学号： 0002 姓名： 李小明 学号： 0003 姓名： 张三丰

显然，需要逐个获取集合中的键值对了。

除了for循环外，Go语言还提供了range关键字。与for结合，也可以实现循环遍历，其使用格式如下：

```Go
for index, value := range variable {
    // 循环体
}
```

其中，index表示索引或键的值；value表示元素的值；variable表示数组、切片或集合变量；由大括号包裹的部分是循环体，可以使用index和value变量。

对于本例，可以如下实现：

```Go
for key, value := range studentInfos {
   fmt.Println("学号：", key, "姓名：", value)
}
```

再次运行，即可得到所要求的输出结果了。

这种for与range结合实现循环遍历的结构，也被称为**for-range结构**。这种结构同样适用于数组和切片。

## 小结

🎉 恭喜，您完成了本次课程的学习！

📌 以下是本次课程的重点内容总结：

1. 获取数组、切片和集合的元素个数
    
2. 获取和修改数组、切片和集合的元素的值
    
3. 数组、切片和集合的循环遍历
    

在实际使用数组、切片和集合时，往往是综合本讲和上一讲内容中的知识点一起使用的。

比如，在使用for循环遍历数组时，需要首先获取元素个数，然后将其作为循环结束的条件。否则，将会引发下表越界错误，导致程序出错。

再比如，使用for-range循环，再循环体内使用元素的值参与其它运算，抑或是根据元素值或集合中键的值进行元素筛选，等等。

➡️ 在下次课程中，我们会介绍如下内容：

- Go语言中的“函数”，包括：
    
    - 函数的定义
        
    - 函数的调用
        

# 函数 一 ｜ 构建“轮子”

在编程领域，我们经常听到一个词——“轮子”，也经常听到一句话——“不要重复造轮子”。这其中的“轮子”在一定程度上就是指本讲以及后续几讲中介绍的“函数”。

实际上，在前面的几讲内容中，我们已经或多或少地用过函数了。比如获取容器内元素个数的len()，用于在控制台输出字符串的fmt.println()等等。这些都是Go SDK中内置的函数，通过这些内置的函数，可以实现一些需求，但并不是全部。有些时候还需要我们实现自定义的函数，以满足项目的独特性需求。

举个例子，还记得我们一直使用的查找素数示例吗？如果要更改查找范围，一直以来的方法是修改最外层循环的终止条件。实际上，更“聪明”的做法是将查找素数的逻辑封装为函数，将循环终止的条件设置为函数的参数。调用这个函数时，只要传入不同的参数，即可实现对查找范围的控制了。是不是很方便呢？

像这种做一次即可反复使用的函数、库等等，就可以称其为“轮子”。它们的共同特点便是：**直接拿来就能用，塞进项目中就能实现想要的一个或多个功能**。因此，对于已经存在且足够好用的轮子，就“不要重复造轮子”了。

本讲就来介绍如何定义、调用函数及相关的技巧和注意事项，具体如下：

1. 普通函数的定义和调用
    
2. 函数的延迟调用
    

## 普通函数的定义和调用

现在，我们就来逐步将查找素数的逻辑封装为函数。

在Go语言中，定义一个普通函数的格式如下：

```Go
func function_name([params_list])([return_values_list]){
    // 函数体
}
```

其中，func关键字表示定义一个函数；function_name是函数名；params_list表示参数列表；return_values_list表示函数的返回值列表；使用大括号包裹起来的部分称为函数体，是函数内部要执行的代码。其中，参数列表和返回值列表是可选的。有些函数无需参数，有些参数运行后并不会有任何返回值，有些函数则无需参数也无需返回值。

先举个简单的例子，下面的函数实现了将参数（即传入的string类型字符串）作为返回值（类型也为string）输出。

```Go
func stringLoop(content string) string {
   return content
}
```

这段代码一共有三行，我们逐行拆解：

- 第一行定义了名为stringLoop的函数，参数列表中，content是参数名，string是参数的类型。当需要多个参数是，使用英文的逗号（,）隔开。再往后表示该函数运行后将返回string类型的结果；
    
- 第二行是函数体，return表示返回函数运行的结果。本例是直接将传入的参数——content变量的值返回；
    
- 第三行是函数的结尾。
    

`❗️ 注意： return语句一般在函数结尾处出现，在该语句后的代码不会被执行。`

下面，尝试调用这个函数，整个函数定义与调用的示例如下：

```Go
func main() {
   result := stringLoop("字符串回环测试")
   fmt.Println(result)
}

// 用于测试的自定义函数
func stringLoop(content string) string {
   return content
}
```

显然，整个程序代码由两个函数组成：main()和stringLoop()。程序运行后，main()函数被调用，声明了result变量，该变量的值来自stringLoop()函数的运行结果。在调用stringLoop()函数时，向其中传入了“字符串回环测试”的字样，因此这个函数运行后，也将原样返回这些文字。并将这些文字赋值到result变量。最后，调用了fmt.Println()函数，输出了result的值。因此，甚至无需真的运行，我们便可得知程序的运行输出结果应该是：

> 字符串回环测试

`❗️ 注意： main()函数和stringLoop()函数时两个不同的函数，Go语言不允许函数的嵌套，因此两个函数应独立定义和实现。`

接下来，我们依葫芦画瓢，改造查找素数的案例，使其用起来更加自由，成为可靠的“轮子”。

为了方便对比，我先将原有的代码搬过来：

```Go
func main() {
   var resultSlice []int
   for i := 2; i < 10; i++ {
      //假定i为素数
      flag := true
      for j := 2; j < i; j++ {
         if i%j == 0 {
            //当i能被某个整数整除时，不是素数
            flag = false
         }
      }
      //如果依旧为true，则i为素数
      if flag {
         //将素数存放到resultSlice数组中
         resultSlice = append(resultSlice, i)
      }
   }
   fmt.Println(resultSlice)
}
```

要做的只有一件事：将参数作为查找范围实现更自由地调用。

我们已经知道，上述代码中查找素数的逻辑实际上就是从头开始，直到输出resultSlice变量为止。因此，我们便可将这部分代码提取出来，封装为一个函数，我们将这个函数起名为findPrimeNumber（查找素数）。显然，该函数需要一个int型的参数，表示查找的最大范围；还需要切片类型的返回值，表示查找的结果。因此，该函数的定义和实现代码如下：

```Go
func findPrimeNumber(max int) []int {
   var resultSlice []int
   for i := 2; i < max; i++ {
      //假定i为素数
      flag := true
      for j := 2; j < i; j++ {
         if i%j == 0 {
            //当i能被某个整数整除时，不是素数
            flag = false
         }
      }
      //如果依旧为true，则i为素数
      if flag {
         //将素数存放到resultSlice数组中
         resultSlice = append(resultSlice, i)
      }
   }
   return resultSlice
}
```

接着，继续改动main()函数，调用findPrimeNumber()，并输出查询结果。

```Go
func main() {
   var resultSlice []int
   resultSlice = findPrimeNumber(10)
   fmt.Println(resultSlice)
}
```

运行整个程序，如无意外，则可在控制台中看到如下输出：

> [2 3 5 7]

到此，findPrimeNumber()函数便成为了一个合格的“轮子”。通过传入不同的int值，可实现查找特定范围内的素数之功能。

接下来抛出一个思考题：在这段代码中，main()函数中的resultSlice和findPrimeNumber()中的resultSlice有何关系呢？

答案是：这二者之间没有任何关系！因为main()函数和findPrimeNumber()函数是两个函数，互相独立，互不影响。各自的resultSlice变量都是在各自的函数体内声明和使用的，无法共用，只是凑巧名称和类型都一样而已。大家不要将它俩混为一谈。

如果理解了这一点，我们再来看看下面这段代码。不要在GoLand中运行，先猜猜它的运行结果：

```Go
func main() {
   var resultSlice []int
   findPrimeNumber(resultSlice, 10)
   fmt.Println(resultSlice)
}

func findPrimeNumber(result []int, max int) {
   for i := 2; i < max; i++ {
      //假定i为素数
      flag := true
      for j := 2; j < i; j++ {
         if i%j == 0 {
            //当i能被某个整数整除时，不是素数
            flag = false
         }
      }
      //如果依旧为true，则i为素数
      if flag {
         //将素数存放到result数组中
         result = append(result, i)
      }
   }
}
```

答案揭晓：这段程序的运行结果为：

> []

相信不少人看到这里会一脸懵。为什么我把main()函数中的resultSlice传入findPrimeNumber()了，并且在findPrimeNumber()中对其做了修改，却并没有使resultSlice发生变化呢？

要解开这个谜团，我们不妨输出 main()函数中resultSlice和findPrimeNumber()中，result的内存地址。因为只有这二者的地址相同，才能证明这两个变量是“一回事”。

输出内存地址的代码示例如下：

```Go
ptr := &variable
fmt.Println(&ptr)
```

其中，variable表示变量名，对应本例为main()中的resultSlice和findPrimeNumber()中的result。

这一对比的结果是显而易见的，main()中的resultSlice和findPrimeNumber()中的result，二者内存地址是不同的！这也就意味着，无论result变量在findPrimeNumber()中作出如何改变，都无法作用到main()中的resultSlice变量上。问题也就跟着来了：在函数间传值的过程中，到底发生了什么呢？

实际上，这里涉及到两个容易混淆的传递概念——**值传递**和**引用传递**。

像上述示例当中的做法，即直接传递一个变量名到另一个函数中，属于**值传递**。按照Go代码的执行策略，发生值传递时，将在另一个函数中自动生成一个值的副本。所以我们才会看到main()中的resultSlice和findPrimeNumber()中的result的内存地址是不同的，因为后者完全是前者的“替身”，我们在findPrimeNumber()函数中只是对替身做了改变，“真身”根本就没有收到影响！

与值传递相对的便是**引用传递**，这种方式在函数间传递的是指针，而指针恰恰是内存地址。这样的传值，无论发生在多少个函数之间，改变将始终作用于相同地址的数据上。

了解过值传递和引用传递后，便很清楚如何修改我们的代码了——只需将原有的值传递改为引用传递，即向findPrimeNumber()函数传递resultSlice的内存地址就行了。当然，还要适当修改findPrimeNumber()函数的定义和逻辑。修改后的完整代码如下：

```Go
func main() {
   var resultSlice []int
   findPrimeNumber(&resultSlice, 10)
   fmt.Println(resultSlice)
}

func findPrimeNumber(result *[]int, max int) {
   for i := 2; i < max; i++ {
      //假定i为素数
      flag := true
      for j := 2; j < i; j++ {
         if i%j == 0 {
            //当i能被某个整数整除时，不是素数
            flag = false
         }
      }
      //如果依旧为true，则i为素数
      if flag {
         //将素数存放到result数组中
         *result = append(*result, i)
      }
   }
}
```

再次运行程序，将输出：

> [2 3 5 7]

除了将值传递改为引用传递外，还有一种“**偷懒式**”修改方法也可使程序正常输出——直接把resultSlice变量声明在函数外，改为**全局变量**，即可在所有函数中访问和修改这个变量了。

之所以称这种方法是“偷懒式”，是因为所有函数都能修改这个全局变量，数据存在一定的安全风险。若不慎错误地修改了变量的值，修复起来也会相对更困难一些了。

## 函数的延迟调用

接下来，我们保持findPrimeNumber()函数不变，在main()函数伊始添加两行神奇的代码：

```Go
func main() {
   defer fmt.Print("素数")
   defer fmt.Print("查找")
   var resultSlice []int
   findPrimeNumber(&resultSlice, 10)
   fmt.Println(resultSlice)
}
```

很明显，main()函数开头的两行代码和普通的代码不同，前面有个“defer”。**“defer”的作用是让整句代码延迟执行，且多个defer存在时，它们的顺序是反向的。**

根据这一规律，我们便可推测上述代码运行的结果将是：

> [2 3 5 7] 查找素数

defer的典型应用场景是执行一些**收尾工作**，通常是在常规逻辑执行结束后释放系统资源。如文件读写、网络IO等等。也用于程序在**发生宕机时的恢复**。

在这里，大家先对defer做到了解、会用即可。后续到了相应的章节处，我们还会和它再次相遇。

## 小结

🎉 恭喜，您完成了本次课程的学习！

📌 以下是本次课程的重点内容总结：

1. 普通函数的定义和调用
    
2. 函数的延迟调用
    

Go SDK中提供了大量实用的函数，我们可以随时调用它们完成项目所需要的功能。此外，我们还可以通过自定义函数，实现项目的独特性需求。

在自定义函数时，我们要掌握**定义函数的格式**以及**调用函数的方法**。无论函数是自用还是提供给团队中的其他成员，甚至是日后作为库发布，都要注意**函数的命名**，并为其添加必要的**注释**。

在调用函数时，要特别留意**值传递**和**引用传递**的区别。值传递会在被调用函数中自动生成一份传入参数的“**副本**”，改动不会影响“真身”；引用传递是在传递**地址**，被调用函数中对其的改变会对传入的参数产生影响。

➡️ 在下次课程中，我们会继续介绍Go语言中的函数，具体内容是：

- 递归算法
    

# 函数 二 ｜ 递归算法，会自转的轮子

在上一讲中，我们学会了如何构建和使用“轮子”。本讲我们进一步深入，介绍如何构建会自转的轮子。这种会自转的轮子在调用时，通过在函数内部调用自身，实现“自转”。在编程领域，这种自己调用自己的方式通常被称为“递归”调用。

然而，递归说起来容易，但要理解并正确使用它并非易事。所以本讲将会史无前例地只讲述这一个知识点，并使用两个实例帮大家学好递归。好了，废话不多说，让我们正式开始吧！

## 计算阶乘

我们先来一同解决一个数学问题——计算阶乘。

回顾一下阶乘的概念。所谓阶乘，就是给定一个正整数，然后从0开始，依次将所有小于及等于该数的正整数做乘法运算。举个例子，给定一个正整数5。5的阶乘是1×2×3×4×5，得到结果是120。因此，5的阶乘是120，写为：5!=120。值得注意的是，0的阶乘等于1。

为了便于讲解，本例先祭出完整代码：

```Go
func main() {
   fmt.Println(calcFactorial(5))
}

func calcFactorial(n int) (result int) {
   if n > 0 {
      result = n * calcFactorial(n-1)
      return result
   }
   return 1
}
```

从宏观上看，上述代码很好解释。main()函数调用了calcFactorial()函数，并传入了int型参数：5，表示要计算5的阶乘。具体的计算工作交给calcFactorial()函数进行。神奇的是，当我们阅读calcFactorial()函数的代码时，发现其中居然再一次调用了calcFactorial()函数。

这样真的可以吗？让我们运行这段代码，可以看到控制台输出了120，结果正确！这到底是怎么一回事呢？

当我们阅读代码时，一种比较好的做法便是放下我们固有的“人类思维”。把自己当作一台电脑，在大脑中运行这段程序。

当向calcFactorial()函数中传入0时，很显然不满足n > 0的条件，直接返回1，即0!=1。这种情况相信大家都能理解吧？

接着，假设向calcFactorial()函数中传入1。此时，n = 1，满足n > 0的条件，开始计算result变量。在这一步，又执行了calcFactorial(n-1)。n-1的结果是0，我们已经知道calcFactorial(0)的结果是1，因此，result变量实际上的计算过程是1 * calcFactorial(0)。所以最终结果是1，即1!=1。

再接着，假设向calcFactorial()函数中传入2。此时，n = 2，满足n > 0的条件，开始计算result变量。在这一步，又执行了calcFactorial(n-1)。n-1的结果是1，我们已经知道calcFactorial(1)的结果是1，因此，result变量的计算过程是1 * calcFactorial(1)。而在执行calcFactorial(1)时，函数内部还执行了calcFactorial(0)。所以在计算result变量的值时，总共分为三步：

1. 2 * calcFactorial(1)
    
2. 2 * (1 * calcFactorial(0))
    
3. 2 * (1 * 1)
    

所以最终结果是2，即2!=3。

说到这，相信大家已经隐隐约约地觉察到一些规律了。我们不妨再继续做些假设。

假设向calcFactorial()函数中传入3，result的值是如何计算的呢？没错，总共分为四步：

1. 3 * calcFactorial(2)
    
2. 3 * (2 * calcFactorial(1))
    
3. 3 * (2 * (1 * calcFactorial(0)))
    
4. 3 * (2 * (1 * 1))
    

最终，3!=6。

注意到每个步骤中的小括号了吗？在程序实际执行时，由于发起调用的一方总是等待被调用的结果，所以计算的顺序便会如此。若要较为完整地描述计算过程，将如下所示：

1. 3 * calcFactorial(2)
    
2. 3 * (2 * calcFactorial(1))
    
3. 3 * (2 * (1 * calcFactorial(0)))
    
4. 3 * (2 * (1 * 1))
    
5. 3 * (2 * 1)
    
6. 3 * 2
    
7. 6
    

最后，我们直接尝试向calcFactorial()函数中传入5。这一次，请不要直接往下看，请大家先主动想想result是如何一步一步地算出来的。

答案如下：

1. 5 * calcFactorial(4)
    
2. 5 * (4 * calcFactorial(3))
    
3. 5 * (4 * (3 * calcFactorial(2)))
    
4. 5 * (4 * (3 * (2 * calcFactorial(1))))
    
5. 5 * (4 * (3 * (2 * (1 * calcFactorial(0)))))
    
6. 5 * (4 * (3 * (2 * (1 * 1))))
    
7. 5 * (4 * (3 * (2 * 1)))
    
8. 5 * (4 * (3 * 2))
    
9. 5 * (4 * 6)
    
10. 5 * 24
    
11. 120
    

怎么样？经过这样一番详尽的拆解，相信大家已经可以读懂递归代码了。

接下来，让我们实际动手，逐步实现递归算法。

## 输出斐波那契数列

先解释一下概念：什么是斐波那契数列。

> 斐波那契数列（Fibonacci sequence），又称黄金分割数列、兔子数列。指的是这样一个数列：1、1、2、3、5、8、13、21、34、……在数学上，斐波那契数列以如下被以递推的方法定义：F(0)=1，F(1)=1, F(n)=F(n - 1)+F(n - 2)（n ≥ 2，n ∈ N）在现代物理、准晶体结构化学等领域，斐波纳契数列都有直接的应用。
> 
> 摘自百度百科：[斐波那契数列](https://link.juejin.cn/?target=https%3A%2F%2Fbaike.baidu.com%2Fitem%2F%25E6%2596%2590%25E6%25B3%25A2%25E9%2582%25A3%25E5%25A5%2591%25E6%2595%25B0%25E5%2588%2597)

简而言之，斐波那契数列（以下简称“数列”）就是由从1开始的若干正整数构成的数列。其特征是第三个数是前两个数字之和，其中开头的两个数都是1。

本示例要求实现一个名为calcFibonacci()的函数，参数是int型，表示要输出数列中第几个数字。

先来实现最为简单的部分。根据数列的规律，开头的两个数字是1，因此当传入的参数小于或等于2时，直接返回1。

```Go
func calcFibonacci(n int) (result int) {
   if n <= 2 {
      result = 1
   } else {
      // 递归调用
   }
   return result
}
```

接下来实现较有挑战的递归调用。我们不妨继续做些假设，当n=3时，result值应如何计算出来呢？

显然，n=3表示列出数列中前3个数字。根据数列的规律，第3个数字应该是前两个数字，也就是第1个和第2个数字之和。因此，当n=3时：

result = calcFibonacci(2) + calcFibonacci(1)。

继续下去，我们会发现如下规律：

- 当n = 4时，result = calcFibonacci(3) + calcFibonacci(2)；
    
- 当n = 5时，result = calcFibonacci(4) + calcFibonacci(3)；
    
- 当n = 6时，result = calcFibonacci(5) + calcFibonacci(4)；
    
- ……
    

可以归纳出：当n > 2时，result = calcFibonacci(n - 1) + calcFibonacci(n - 2)。

使用归纳出的结论补充calcFibonacci()函数，并尝试在main()函数中调用它。完整代码如下：

```Go
func main() {
   fmt.Println(calcFibonacci(5))
}

func calcFibonacci(n int) (result int) {
   if n <= 2 {
      result = 1
   } else {
      result = calcFibonacci(n-1) + calcFibonacci(n-2)
   }
   return result
}
```

如上代码所示，向calcFibonacci()中传入了5。程序运行后，控制台将输出数列中第5个数字：

> 5

当向calcFibonacci()函数中传入5时，变量result的值计算过程如下：

1. calcFibonacci(4) + calcFibonacci(3)
    
2. (calcFibonacci(3) + calcFibonacci(2)) + (calcFibonacci(2) + calcFibonacci(1))
    
3. ((calcFibonacci(2) + calcFibonacci(1)) + 1) + (1 + 1)
    
4. ((1 + 1) + 1) + (1 + 1)
    
5. (2 + 1) + 2
    
6. 3 + 2
    
7. 5
    

请大家尝试向calcFibonacci()函数中传入10，并试着写出result的值计算过程。

## 使用递归的注意事项

到此，递归算法的使用已经介绍完毕。通过两个示例的练习，相信大家对递归的使用已经掌握得差不多了。不过，要使用好递归算法，还有几个点需要注意。

- 若要使用递归算法，务必要确认被解决的问题可以被拆分为多个子问题；
    
- 被拆分的子问题及拆分前的原问题除了数据规模有大小区别外，计算的思路是相同的；
    
- 递归必须有终止的条件，否则将陷入死循环，程序无法正常结束。
    

请大家结合示例体会前两点。

## 总结

🎉 恭喜，您完成了本次课程的学习！

📌 以下是本次课程的重点内容总结：

1. 递归算法
    

本讲使用了两个示例来介绍递归算法。在计算阶乘的例子中，使用直接阅读代码的方法深刻体会了递归算法在计算机中的运算步骤；在输出斐波那契数的例子中，我带着各位手把手地实现了递归算法。在这个示例中，calcFibonacci()函数内部调用了两次自身实现了递归。

本讲的最后，还列出了三个使用递归算法的注意事项。

在实际开发中，递归算法通常用于获取某个目录（文件夹）中的所有目录/文件，以及子目录中的目录/文件，从而达到父目录的大小统计、删除等操作。此外，像汉诺塔、归并/分治/快速排序法、解析XML格式文件等等都可使用递归算法实现。感兴趣的朋友可以搜索相关的内容了解更多详情。

➡️ 在下次课程中，我们会继续介绍Go语言中的函数，具体内容是：

- 匿名函数
    

# 函数 四 ｜ 使用闭包实现工厂模式

在之前的三次课程中，我们分别介绍了Go语言中普通函数的定义和调用、匿名函数的定义和调用、递归算法以及回调式编程。在本次课中，我们将介绍有关函数的最后一个典型的用法，它就是：**使用闭包实现****工厂模式**。

很明显，本讲内容将为大家讲述两个重要的概念：**闭包**和**工厂模式**。

闭包在某些编程语言（如Java）中还被称为Lambda表达式；工厂模式则是编程领域中设计模式的其中一种。

是不是听上去似乎有点摸不着头脑，感觉很深奥？其实它并不像想象中的那么难，我们还是用实际的示例来介绍什么叫做工厂模式，以及什么是闭包。

## 创建角色（工厂模式）

看到这个标题，相信各位的第一反应是：网络游戏？没错，我们在玩网络游戏的时候免不了要创建一个游戏角色。但不知大家有没有想过，无论游戏中承载了多少个玩家，每个角色都是由既定的**属性**以及不确定的**属性值**排列组合而成的。

举例而言，下面是两个简化的游戏角色，他们都有角色名、职业、性别组成。

1. 角色名：狂斩天下；职业：战士；性别：男
    
2. 角色名：温玉琳琅；职业：法师；性别：女
    

`💡 提示：在实际游戏中，还会有更多的属性和属性值，如皮肤、坐骑等等。这里为了讲解方便，简化了其它属性。`

如果要用Go语言编程的方式，可以按照如下方式创建这两个角色：

```Go
// 游戏角色创建器，传入角色名、职业和性别
func createPlayer(name string, career string, gender string) func() (string, string, string, int, int) {
   var hp = 0
   var mp = 0
   if career == "战士" {
      hp = 150
      mp = 100
   } else if career == "法师" {
      hp = 100
      mp = 200
   }
   // 闭包
   return func() (string, string, string, int, int) {
      return name, career, gender, hp, mp
   }
}
func main() {
   playerA := createPlayer("狂斩天下", "战士", "男")
   nameA, careerA, genderA, hpA, mpA := playerA()
   fmt.Println(genderA, careerA, nameA, hpA, mpA)

   playerB := createPlayer("温玉琳琅", "法师", "女")
   nameB, careerB, genderB, hpB, mpB := playerB()
   fmt.Println(genderB, careerB, nameB, hpB, mpB)
}
```

直接运行上述代码，控制台将输出如下结果：

> 男 战士 狂斩天下 150 100
> 
> 女 法师 温玉琳琅 100 200

从结果处可以看到，两个角色已经被创建好了，且拥有不同的血量值（hp）和魔法值（mp）。

从createPlayer()函数入手，可以看到：该函数最终的返回值类型为func() (string, string, string, int, int)，这是一个匿名函数，包含了传入的角色名、职业、性别。此外，在createPlayer()函数体内还根据不同的职业给了不同的血量值和魔法值，这两个值也会一并作为返回值返回。

再从main()函数入手，看到函数体中的空行了吗？这是我故意为之的。这个空行将整个main()函数分成了上下两个相似的部分，每个部分都有三行代码。以上半部分为例：

- 第一行声明了变量playerA，它将表示一个游戏角色。并调用了createPlayer()函数，向其中传入了角色名、职业和性别（像不像在游戏一开始的时候创建角色的过程？）。最后，将函数赋值给了playerA；
    
- 第二行声明了多个变量，并通过playerA调用了createPlayer()函数，并将函数运行后的结果一一对应地赋值给了多个变量；
    
- 第三行则是向控制台输出了上一行声明并赋值的变量。
    

main()函数的下半部分无需多做解释，和上半部分执行了类似的逻辑，只不过是传入的参数不同，得到的结果便会随时变化。

以此类推，无论创建多少个角色，只需要如法炮制即可。

简单地说，像这种**通过输入不同参数自动地生成不同数据对象的设计模式就可以被称为****工厂模式**了。它就像一座工厂那样，**将不同的输入经过一系列标准化的流程，最终产出独具特色的数据对象**。

使用工厂模式是很有优势的，比如当我想创建一个数据对象的时候，我只要知道它的名字就行了，比如本例中的createPlayer()。而创建对象的细节被封装在createPlayer()函数之中，因此在创建对象的时候便无需关注具体的过程细节了。

但工厂模式带来的弊端也很明显，在使用时，每次创建一个数据对象都要声明一个新的变量，并将createPlayer()赋值给这个变量。因此，createPlayer()函数也会随之增加，对性能多多少少是会有一定影响的。

`💡 提示：严格意义上说，设计模式中的工厂模式又可分为简单工厂模式、工厂方法模式和抽象工厂模式。篇幅所限，此处不再展开讲解。`

## 角色的动作（闭包）

接下来，进入游戏，便会发生战斗了。

我们知道，每个角色的动作、血量值和魔法值都是独立存在的，它们互不影响。

假设现在playerA和playerB狭路相逢，要打架了。playerB是法师，擅长远程攻击，消耗了15点魔法值来打playerA。playerA只能近战，这时候playerA还没走到playerB跟前，只能挨打，损失掉20点血量。

如此描述的过程可使用代码如下实现：

```Go
//发生战斗，B消耗15点魔法值
mpB -= 15
//发生战斗，A失去20点血量值
hpA -= 20
fmt.Println(nameB, hpB, mpB)
fmt.Println(nameA, hpA, mpA)
```

将这段代码片段添加到main()函数末尾，并运行程序，可得如下输出：

> 男 战士 狂斩天下 150 100
> 
> 女 法师 温玉琳琅 100 200
> 
> 温玉琳琅 100 185
> 
> 狂斩天下 130 100

很明显，名为温玉琳琅的法师的魔法值由200变为185，名为狂斩天下的战士的血量值由150变为130。可见，这两个角色的属性各自“持有”，改变某个角色的属性值并不会影响到另一个角色对应的属性值。

代表两个角色的playerA和playerB变量分别“**持有**”不同的变量，这些变量相互不会影响。这便是“**闭包**”的意义，这种相互不会影响的现象称为闭包的“**记忆效应**”。

总地来说，闭包是匿名函数（本例中createPlayer()函数的返回值）与匿名函数所引用环境（createPlayer()函数的返回值中所使用的变量）的**组合**。playerA和playerB不仅存储了createPlayer()函数的返回值，还存储了闭包的状态（hp、mp及其它变量）。

## 闭包的意义

通过前面的例子，介绍了闭包的使用方法和特性。那么，为何要使用闭包呢？它和普通函数有何区别呢？

其实，使用闭包和使用普通函数的最大区别在于：

1. 如果是普通函数，那就是一次性买卖，函数执行完毕后就**无法再更改函数中变量的值**；
    
2. 使用闭包，函数就成为了一个变量的值。只要变量还在，函数就会一直处于存活并独享内部状态。方便后期**更改函数中变量的值**。
    

另外，使用闭包还能起到一定的**数据保护**作用。比如本讲示例中的hp、mp值，如果不在闭包内来维护它们的话，值很可能会被错误地修改。

## 总结

🎉 恭喜，您完成了本次课程的学习！

📌 以下是本次课程的重点内容总结：

1. 闭包
    

闭包可以看成函数的高阶应用，是Go语言高级开发的必备技能。

本讲通过模拟游戏中创建角色和角色之间战斗的过程介绍了Go语言中闭包的使用。

同时，通过与普通函数对比，闭包可以更方便地修改函数中变量的值，并可在一定程度上保护数据不被意外篡改。

本讲是最后一个关于函数的课程，下一讲我们会一同进入新的模块——结构体。

有C语言编程经验的朋友对结构体一定不会感到陌生。Go语言的整体设计基于C语言，并做了完善，吸收了C语言及其它编程语言的优势。因此，Go语言中的结构体不仅可实现类似C语言中结构体的作用，还可实现类似面向对象语言中的的构造函数、方法、继承（包括嵌套）。这些内容我们都会在后续的课程中逐一介绍，让我们拭目以待吧！

➡️ 在下次课程中，我们会介绍Go语言中的结构体，具体内容是：

- 结构体的定义和使用
    
- 匿名结构体的定义和使用
    

# 结构体 一 ｜ 万物皆为“结构体”

相信大家都听过这样一句话：“万物皆对象”。这句话来源于面向对象编程语言，所倡导的精神是**将现实的事物“抽象”出来**。必要时通过各种“组成手段”将这些抽象出的“对象”重新组合在一起，最终的效果则是将现实中的万事万物描述清楚。

这种“抽象”思维的优势很明显，它可以**将复杂的问题简单化**，更符合人类思维，可以实现**从执行者到指挥者的角色转换**。

Go语言脱胎于C语言（C语言是面向过程的），同时吸收了面向对象语言的编程思想和优势，极大地扩充了C语言中“结构体”的能力。作为开发者，不仅可以像传统C语言那样定义和使用结构体，还可以实现面向对象编程语言所具有的构造函数和方法、类型继承等。可以说：Go语言中的结构体**使用简单、灵活，扩展性强**。

说得这么热闹，相信大家已经跃跃欲试，想要和“结构体”交朋友了。从本讲开始，我将使用3讲的篇幅来为大家介绍Go语言中的结构体。作为第一讲，我们要从最基本的知识点开始，具体包括：

- 结构体的定义和使用；
    
- 匿名结构体的定义和使用。
    

当然，如果你对前面所述的一些词汇比较陌生，也没有关系，学完这3讲，相信您不仅熟悉、会用，甚至还能给别人讲清楚呢！好了，废话不多讲，我们进入正题。

## 为何需要结构体

为什么程序中需要结构体呢？在之前的各种示例中，我们使用的通常是基本数据类型。比如int、float、bool、string。但在实际项目中，所面对的情况往往会复杂很多。

比如，要做一个图书管理系统，每本图书都有相应的属性信息：图书名称、作者名称、出版社、分类、ISBN码等等。又或者要做一个学生管理系统，每个学生也有相应的属性信息：姓名、性别、年龄、年级、班级、学号等等。像这类可以用若干属性（这些属性还有可能是不同的数据类型）来描述的“对象”，就需要使用结构体了。

所以，我们便可得出结构体的定义——**结构体是由一系列具有相同类型或不同类型的数据构成的数据集合。**

`💡 提示：此处所指的“类型”，可以是基本数据类型，也可以是其它结构体。本讲仅涉及由基本数据类型构成的结构体。`

## 结构体的定义

还记得在上一讲中我们用过的例子吗？我们创建了两个游戏角色：“狂斩天下”和“温玉琳琅”。他们都由3个属性构成：角色名、职业和性别。

`💡 提示：在实际项目中使用的结构体属性大多比本例更为复杂，但无非是数量上的增加。为了讲解方便，这里仍仅使用这3个属性为例。`

在Go语言中，定义结构体的标准格式为：

```Go
type StructName struct {
   // 属性字段
}
```

其中，开头的type表示要定义自定义的类型；StructName代表结构体的名称；struct表示结构体类型；由大括号包裹的部分是属性列表，由一个或若干个字段构成。字段的名称不允许重复。

举例，若要定义用于描述游戏角色的结构体，名称为Player，则可如下实现：

```Go
type Player struct {
   // 角色名
   name string
   // 职业
   career string
   // 性别
   gender string
}
```

具体来说，本例定义了名为“Player”类型的数据，该数据的类型为结构体。这个结构体中由3个属性构成，分别使用3个字段来描述。包括角色名（name）、职业（career）和性别（gender），它们都是string类型。

实际上，Player作为**自定义类型，和基本****数据类型****相似，同样遵循Go语言官方建议的命名方法（驼峰式），****作用域****的规则限制也同样适用**。

## 结构体的使用

一旦结构体完成定义，它就已经准备就绪，随时可用了。和基本数据类型相同，使用结构体依然需要声明和初始化。

### 结构体的声明与初始化

下面的代码声明了Player类型的变量，并完成初始化。最终创建了狂斩天下角色：

```Go
playerA := Player{
   name:   "狂斩天下",
   career: "战士",
   gender: "男",
}
```

如上代码所示，playerA就是狂斩天下了。

`❗️ 注意：在初始化结构体时，每个字段需要使用逗号分割开。在定义结构体时则不用。`

在初始化结构体时，可以一次性地赋值所有字段，也可以只赋值部分字段，甚至不赋值。下面几种写法都是允许的：

```Go
playerA := Player{
   name:   "狂斩天下",
   gender: "男",
}
```

```Go
playerA := Player{}
```

对于本例这种一口气赋值所有字段的行为，Go语言提供了更简洁的方式，如下所示：

```Go
playerA := Player{
   "狂斩天下",
   "战士",
   "男",
}
```

注意到区别了吗？这种简洁方式省略了所有字段名。但为了确保字段的正确匹配，需要按照结构体内部定义的顺序进行赋值，且必须一次完成所有属性赋值。即定义时是角色名、职业、性别；初始化时也应是角色名、职业、性别，顺序不能颠倒，且值缺一不可。

当我们完成初始化后，试试使用fmt.Println()函数输出playerA的值，将得到如下结果：

> {狂斩天下 战士 男}

下面，请各位动手练习，声明playerB变量，并使用温玉琳琅（温玉琳琅，法师，女）的角色信息初始化它。

下面是参考代码：

```Go
playerB := Player{
   name:   "温玉琳琅",
   career: "法师",
   gender: "女",
}
```

### 访问和修改结构体的属性值

日复一日，随着游戏角色等级的不断提高，狂斩天下迎来了转职机会。他将由战士转为战神，需要改变结构体内的职业属性值。

在Go语言中，改变或完善（针对初始化时未赋值的情况）结构体内属性值的方法是非常简单的，其格式为：

```Go
变量名.属性名=值
```

举例来说，狂斩天下对应的是playerA变量，职业对应的是career字段。因此，若要完成转职，应如下实现：

```Go
playerA.career = "战神"
```

再次向控制台输出playerA的值，可以看到如下输出：

> {狂斩天下 战神 男}

可以看到，只有职业发生了变化，其它属性仍保持不变。

另一方面，如果我们想单独获取playerA变量的某个属性值，也可以使用类似的方式。举例来说，获取playerA的角色名，实现方式为：

```Go
fmt.Println(playerA.name)
```

运行结果为：

> 狂斩天下

到此，我们已经介绍了普通结构体的定义以及结构体变量的声明、初始化和字段访问（包括取值和修改）。下面我来提个问题，大家一起思考。

在上一讲中，我们使用闭包实现了工厂模式。它也能定义游戏角色，本讲的结构体也能定义游戏角色。这二者之间有何区别，为何要有不同的定义方式呢？工厂模式产出的产品——游戏角色除了包含给定的值外，还有代表血量和魔法值的HP和MP。但目前为止，结构体只能做到“给什么，有什么”。这到底是怎么一回事呢？

当我们回顾上一讲内容时，我们不难发现：闭包的目的在于起到一定的数据保护作用（对于HP、MP而言）。但是，使用结构体可以实现面向对象语言中的构造函数、方法、继承等等特性，这些却是闭包无法做到的。

## 匿名结构体

在实际开发中，还有一类情况，就是某个结构体的作用域很小，甚至只存在于某个函数内部，或是无需创建太多的该结构体变量等等。对于上述情况，Go语言允许我们使用匿名结构体简化编码，即使用匿名结构体。

`💡 提示：这是本讲第二次介绍简化编码的方式了，这便是Go语言中结构体使用简便特性的体现。大家还记得上一个简化编码是用来做什么吗？答案是——初始化结构体变量`

举例来说，还是游戏中的场景。某天，温玉琳琅来到许愿树下进行许愿，这一天是她的生日，许愿树这个植物仅在生日场景中出现。因此为了简化编码，考虑使用匿名结构体来定义和使用它。

使用匿名结构体的方法并不难，实际上就是省略了单独的结构体定义。而是将定义和相关变量的声明、属性赋值合三为一处理。如果我们要声明一个变量来表示许愿树，示例代码如下所示：

```Go
wishingTree := struct {
   height   float64
   width    float64
   treeType string
}{
   height:   22.5 * 100,
   width:    50,
   treeType: "banyan"}
fmt.Println(wishingTree)
```

仔细阅读上述代码，wishingTree便是表示许愿树变量了，它是结构体（struct）类型。结构体内包含3个属性，分别是浮点型的高度（height）、浮点型的胸径（width）以及字符串型的树品种。这3个属性由一个大括号包裹起来。紧随其后的大括号是为属性赋值的过程，其规则依然是允许全部赋值，也允许部分赋值。简化的赋值方式同样适用，这里不再赘述。

`❗️ 注意：即使不为任何属性赋值，第二个大括号也是必不可少的，否则将引发编译时错误，程序无法被编译和运行。`

运行上述代码，可见控制台如下输出：

> {2250 50 banyan}

## 总结

🎉 恭喜，您完成了本次课程的学习！

📌 以下是本次课程的重点内容总结：

- 结构体的定义和使用；
    
- 匿名结构体的定义和使用。
    

本讲是结构体系列专题的开篇，介绍了普通结构体的定义、结构体变量的声明、赋值以及结构体内部属性的取值和修改。在赋值环节，还介绍了简化的赋值方式。

在使用结构体变量时，我们要明确的使用原则是：结构体变量和基本数据类型一样，都是变量。因此也需要声明和初始化，也遵循驼峰法的命名规则与函数作用域限制。

另外，本讲还介绍了匿名结构体，它是普通结构体的简化使用，也是实现JSON格式序列化和反序列化的基础。

关于匿名结构体的更多使用场景，包括序列化和反序列化JSON格式，感兴趣的朋友可以阅读：[一文读懂Go匿名结构体使用场景 - 掘金 (juejin.cn)](https://juejin.cn/post/7040361996553814023)

➡️ 在下次课程中，我们会继续介绍Go语言中的结构体，具体内容是：

- 使用结构体实现构造函数
    
- 使用结构体实现方法
    

# 结构体 二 ｜ 构建有生命的对象

在上一讲中，我们已经学习了Go语言中结构体、匿名结构体的定义和使用。并以创建游戏角色为例，演示了在真实开发环境中的应用。不过，关于结构体的故事还没有完结。

请大家思考这样一个场景：在真实世界中，存在不同品种、不同毛色、不同体重、不同年龄以及其它不同特征的狗。每一只狗又能独自完成动作，比如吃饭、大叫、睡觉、奔跑等等。在大多数面向对象编程语言中，通常会**使用“构造函数”来描述每一只狗的特征，使用“方法”来让某一只狗完成特定的动作。** 在Go语言中，则**使用结构体来实现构造函数和方法**。

从本质上说，Go语言的类型或结构体本身是没有构造函数功能的，但是我们可以**使用结构体初始化的过程来模拟实现构造函数**。从这一点上可以看出Go语言中的结构体使用起来是非常灵活、好用的。

接下来，本讲将以“狗的特征和动作”为例，向大家讲述如何使用结构体来实现：

- 面向对象语言中的构造函数；
    
- 面向对象语言中的方法。
    

## 构建独一无二的对象——构造函数

显然，标题中所说的“对象”，就是本例中的小狗了。依照惯例，我依然尽量简化代码，让各位更好地理解语言本身。

本例使用品种（string）、年龄(int)、体重(float)、性别(int)这四个特征来创建“狗”对象，根据我们现有的知识，若要使用结构体来描述，其代码实现类似如下：

```Go
type Dog struct {
   Breed  string
   Age    int
   Weight float64
   Gender string
}
```

既然说，构造函数是通过使用结构体初始化的过程来模拟实现的，我们不妨编写一个函数，将狗的四个特征作为参数传入其中，并最终返回Dog类型的变量。如此一来，一旦这个函数被调用后，便会生成一个独一无二的Dog类型变量。代码示例如下：

```Go
func NewDog(breed string, age int, weight float64, gender string) *Dog {
   return &Dog{
      Breed:  breed,
      Age:    age,
      Weight: weight,
      Gender: gender,
   }
}
```

类似NewDog()这样的函数，其作用与面向对象语言中的构造函数类似。如此，我们便使用结构体实现了Go语言中并未原生支持的构造函数。

构造函数在使用时非常简单，我们只需声明一个变量，并通过调用NewDog()函数为其赋值即可。比如下面这段完整的代码，就创建了两只胖瘦不同柴犬：

```Go
type Dog struct {
   Breed  string
   Age    int
   Weight float64
   Gender string
}

func NewDog(breed string, age int, weight float64, gender string) *Dog {
   return &Dog{
      Breed:  breed,
      Age:    age,
      Weight: weight,
      Gender: gender,
   }
}

func main() {
   fatShibaInu := NewDog("Shiba Inu", 2, 12.0, "公")
   weakShibaInu := NewDog("Shiba Inu", 2, 7.0, "公")
   fmt.Println(fatShibaInu)
   fmt.Println(weakShibaInu)
}
```

运行本例，控制台将输出：

> &{Shiba Inu 2 12 "公"}
> 
> &{Shiba Inu 2 7 "公"}

请大家关注代码的结构以及main()函数中的调用方式。为了讲解方便，我把结构体、相应的构造函数和main()函数放到了一起。一种更好的做法是将它们分开放到两个Go源码文件中，那样做会使代码结构更清晰、更有条理，日后维护起来就会更轻松了。

相信不少朋友可能会有疑问：使用构造函数，和直接创建结构体，似乎没有什么区别。就拿fatShibaInu变量来说吧，下面两种写法都能达到目的。

- 使用构造函数：
    

```Go
fatShibaInu := NewDog("Shiba Inu", 2, 12.0, "公")
```

- 不使用用构造函数：
    

```Go
fatShibaInu2 := &Dog{
   Breed:  "Shiba Inu",
   Age:    2,
   Weight: 12.0,
   Gender: "公",
}
```

乍看上去还真是一样，但我们考虑一种情况——使用多国语言。

像年龄和体重倒没关系，关键是品种和性别。就拿性别来说吧，当使用“公”来赋值时，只有懂汉语的人能看懂。所以更多时候我们使用0和1分别代表公和母，这样就屏蔽了语言不同造成的理解上的困难。

所以，我们就非常迫切地需要在赋值和取值过程中进行一个“转换”处理。在赋值时将不同语言中表达性别的文字转换成0或1，并在取值时反向转换。

因此，我们修改Dog的结构体和构造函数如下：

```Go
type Dog struct {
   Breed  string
   Age    int
   Weight float64
   Gender int
}

func NewDog(breed string, age int, weight float64, gender string) *Dog {
   genderValue := 0
   if gender == "公" {
      genderValue = 0
   } else if gender == "母" {
      genderValue = 1
   }
   return &Dog{
      Breed:  breed,
      Age:    age,
      Weight: weight,
      Gender: genderValue,
   }
}
```

如此修改后，NewDog()函数内部完成了对gender参数的转换，尽管传入的是汉字，但最终创建Dog变量时用的却是数字。main()函数中创建fatShibaInu变量无需做任何修改，依然使用汉字来表示性别即可。

反观直接创建结构体的方式，就只能传入0和1了：

```Go
fatShibaInu := &Dog{
   Breed:  "Shiba Inu",
   Age:    2,
   Weight: 12.0,
   Gender: 0,
}
```

## 让对象“动起来”

### 获取“静态指标”

经过上述一番修改，再次运行本例，控制台的输出就变为：

> &{Shiba Inu 2 12 0}
> 
> &{Shiba Inu 2 7 0}

最后的“0”，表示的就是性别了。显然，这是不好理解的，我们需要再做一个“转换”，将0和1转换为汉字的“公”和“母”。为了完成这个转换，我们需要定义“方法”。

在Go语言中，方法和函数的定义格式非常像，大家可不要搞混了。由于方法和对象存在紧密的关系，因此在定义的格式上需要**接收器**，具体格式如下：

```Go
func (接收器变量 接收器类型) 方法名(参数列表) (返回参数) {
    函数体
}
```

其中，**接收器变量和接收器类型共同构成了接收器**；参数列表是可选的；返回参数也是可选的；方法名无需多做解释。

对应到本例，我们就可以创建一个名为getGender()的方法，接收器就是Dog类型的指针，无需任何参数，返回值则是string类型的表示性别的汉字。代码示例如下：

```Go
func (d *Dog) GetGender() string {
   if d.Gender == 0 {
      return "公"
   } else if d.Gender == 1 {
      return "母"
   }
   return ""
}
```

GetGender()通过fatShibaInu变量来调用，具体如下：

```Go
fmt.Println(fatShibaInu.GetGender())
```

运行后，可以看到控制台中会输出：

> 公

### 再论接收器

为对象定义方法时，需要注意接收器的类型。使用指针与否，将决定了是否对原始变量产生影响。本例使用了*Dog，即指针类型，在方法中对该类型变量（d变量）的任何影响都将影响原始变量（fatShibaInu）；反之，若使用Dog类型，则不会影响。

其原因是当不使用指针类型变量时，方法中的接收器变量实际上是对原始数据的“拷贝”，所做出的改变也仅仅会作用于这份“拷贝”的数据上，并不会影响到原始数据。

对比来说，我们分别定义两个不同的方法——GrowUp()和GrowUp2()，前者使用指针类型接收器，后者不使用。方法体均是对相应变量中的年龄属性自增1，然后在控制台输出运行结果。测试代码关键部分如下：

```Go
func (d *Dog) GrowUp() {
   d.Age++
}

func (d Dog) GrowUp2() {
   d.Age++
}

func main() {
   fatShibaInu := NewDog("Shiba Inu", 2, 12.0, "公")

   fatShibaInu.GrowUp()
   fmt.Println(fatShibaInu)

   fatShibaInu.GrowUp2()
   fmt.Println(fatShibaInu)
}
```

运行结果为：

> &{Shiba Inu 3 12 0}
> 
> &{Shiba Inu 3 12 0}

显然，虽然GrowUp2()方法也对d变量中的Age属性做了自增1计算，但并未影响原始数据。

### 让对象“动起来”

到此，我们已经掌握了如何使用结构体实现构造函数和方法。接下来到了该让对象“动起来”的时候了。

之前，我们已经声明了两个Dog类型的变量——fatShibaInu和weakShibaInu。要知道一只体重正常的成年雄性柴犬大概在9公斤左右。所以fatShibaInu过重了，要多运动来减肥；weakShibaInu太轻了，要多补充营养。那么，多运动和补营养便是它们接下来的动作了。

所以，我们不妨继续实现两个方法：一个叫做Sport()，每次执行后，体重都减0.1KG；另一个叫做Eat()，每次执行后，体重增加0.1KG。同时，向控制台输出具体的动作内容。代码如下：

```Go
func (d *Dog) Sport() {
   fmt.Println("做运动！")
   d.Weight -= 0.1
   fmt.Println("我减重到了", d.Weight)
}

func (d *Dog) Eat() {
   fmt.Println("多吃饭！")
   d.Weight += 0.1
   fmt.Println("我增重到了", d.Weight)
}
```

接着，让fatShibaInu执行Sport()方法；让weakShibaInu执行Eat()方法：

```Go
func main() {
   fatShibaInu := NewDog("Shiba Inu", 2, 12.0, "公")
   weakShibaInu := NewDog("Shiba Inu", 2, 7.0, "公")
   fatShibaInu.Sport()
   weakShibaInu.Eat()
}
```

再次运行程序，可以看到控制台如下输出：

> 做运动！
> 
> 我减重到了 11.9
> 
> 多吃饭！
> 
> 我增重到了 7.1

长此以往，这两只柴犬都能回到正常的体重了。要注意的是，在写代码的时候请务必让每只狗做正确的事情，不要让该运动的柴犬继续吃吃吃，也不要让该补充食物的柴犬做锻炼。

## 总结

🎉 恭喜，您完成了本次课程的学习！

📌 以下是本次课程的重点内容总结：

使用结构体实现：

- 面向对象语言中的构造函数；
    
- 面向对象语言中的方法。
    

本讲是结构体系列专题的第二篇，得益于Go语言设计的灵活，我们只需要结构体就能实现面向对象语言中的构造函数和方法了。

说到构造函数，其关键点要掌握如何使用结构体初始化的过程来模拟实现。同时，还要明白这样做和直接创建结构体的区别和优势。

说到方法，首先要掌握的就是定义方法的格式。其次还要明白接收器的概念以及不同类型对原始数据的影响。

➡️ 在下次课程中，我们会介绍Go语言结构体的最后一部分知识，具体内容是：

- 使用结构体实现继承
    

# 结构体 三 ｜ 继承，代码中的“父”与“子”

在上一讲中，我们结合两只柴犬的例子介绍了如何构建独一无二的对象，以及如何让对象“动起来”的方法。本讲我们继续深入结构体的讲解，也是结构体部分的最后一讲——使用结构体实现继承。

我们已经知道，构造函数和方法是面向对象语言所具备的能力，继承亦然。Go语言的语法设计非常灵活、简单和易用，仅依靠结构体，便可实现上述所有能力。

## 什么是继承

继承在实际开发中用途同样非常广泛，甚至在现实生活中也有很多类似的应用。

举例而言，在任何一家公司，都是由很多人组成的，不同的人有不同的职务，比如总经理、部门经理、职员等等。发现了吗？无论是总经理、部门经理还是职员，都是由人派生出来的，他们首先属于“人”，然后再属于某个职务。

如果把“人”和总经理等等具有具体职务的人都看作是结构体的话，“人”便是他们的“父结构体”，无论是何种职务的人，都由这个父结构体派生出来，具有父结构体所有的属性。然后根据职务不同，拥有独特性的属性。可以看作是“子结构体”。

从另一个角度看，这些 **“子结构体”扩展了“父结构体”** 。作为“子结构体”，**不仅可以使用“父结构体”的属性，还拥有自己的属性**。如果说 **“父结构体”是概括的，抽象的，那么“子结构体”就是具体的，详细的**。

具体来说，假如“人”结构体具有较为通用的姓名、年龄、性别三个属性，可以执行吃饭、睡觉、走路、奔跑四个动作。作为派生出的“总经理”还额外具有持股比例属性，可以额外执行安排工作任务的动作……

`💡 提示：发现了吗？这个例子中，作为“父结构体”的“人”并没有直接使用，仅用它派生出的“子结构体”就能描述整个公司的组织架构了。但这并不表明“父结构体”永远不会直接使用，具体还需要根据实际开发需求的不同而定。`

从本质上说，**Go语言中****继承****，是通过结构体的嵌套来实现的。**

为了让各位更好地理解，接下来我将使用动物（Animal）作为父结构体，鸟（Bird）和狗（Dog）作为子结构体，来介绍如何使用结构体实现面向对象中的继承特性。

## 结构体的嵌套

我们先来实现作为父结构体的动物（Animal），这个结构体具有名字（Name）、年龄（Age）和性别（Gender）属性。

`💡 提示：请留意这三个属性也是本例中所有子结构体所具有的。`

示例代码如下：

```Go
type Animal struct {
   Name   int
   Age    int
   Gender string
}
```

接下来，以子结构体鸟（Bird）为例，它还具有翅膀颜色的属性。因此，Bird的结构体定义示例如下：

```Go
type Bird struct {
   WingColor    string
   CommonAnimal Animal
}
```

很明显地，Bird结构体中包含了一个名为CommonAnimal的Animal类型成员，而Animal类型就是我们刚刚定义好的结构体。如此，便完成了结构体的嵌套，即把Animal嵌入Bird中。从此，Bird也具有了Animal中的Name、Age和Gender属性了。

继续使用上一讲中“构造函数”的知识，创建Bird类型的构造函数：

```Go
func NewBird(name string, age int, gender string, wingColor string) *Bird {
   return &Bird{
      WingColor: wingColor,
      CommonAnimal: Animal{
         Name:   name,
         Age:    age,
         Gender: gender,
      },
   }
}
```

接着，鸟还有“飞行”的动作。使用上一讲中“方法”的知识，创建Bird类型的“飞行”方法：

```Go
func (b *Bird) Fly() {
   fmt.Println("我起飞啦！")
}
```

关于“鸟”的结构体定义、构造函数和方法的实现到此先告一段落。我们回到main()函数中使用它们。

在main()函数中，首先声明一个变量，名为bird，使用NewBird()构造函数为其赋值，然后再调用Fly()方法，让小鸟执行飞行动作。完整的代码如下：

```Go
type Animal struct {
   Name   string
   Age    int
   Gender string
}

type Bird struct {
   WingColor    string
   CommonAnimal Animal
}

func NewBird(name string, age int, gender string, wingColor string) *Bird {
   return &Bird{
      WingColor: wingColor,
      CommonAnimal: Animal{
         Name:   name,
         Age:    age,
         Gender: gender,
      },
   }
}

func (b *Bird) Fly() {
   fmt.Println("我起飞啦！")
}

func main() {
   bird := *NewBird("小鸟", 1, "公", "绿色")
   fmt.Println(bird)
   bird.Fly()
}
```

运行这段代码，可以看到控制台的输出内容如下所示：

> {绿色 {小鸟 1 公}}
> 
> 我起飞啦！

从输出的格式上，我们也可看出，Animal类型确实被Bird类型嵌入其中。那么，问题也随之而来：若想访问Bird中的Animal中的Name属性值，该怎么做呢？

思路其实非常简单，也是层层嵌套地访问就可以了。就拿本例来说，bird.CommonAnimal访问到的是CommonAnimal属性，它是Animal类型；bird.CommonAnimal.Name，访问到的就是CommonAnimal中的Name属性了。

类似地，我们继续定义子结构体狗（Dog），它拥有毛色（Color）属性。还有犬吠（Bark）动作。请读者参考上面小鸟（Bird）部分的代码，独立完成狗（Dog）部分的代码，要求依然使用构造函数（NewDog()）和方法（Bark()）。

完整的代码如下：

```Go
type Animal struct {
   Name   string
   Age    int
   Gender string
}

type Dog struct {
   Color        string
   CommonAnimal Animal
}

func NewDog(name string, age int, gender string, color string) *Dog {
   return &Dog{
      Color: color,
      CommonAnimal: Animal{
         Name:   name,
         Age:    age,
         Gender: gender,
      },
   }
}

func (d *Dog) Bark() {
   fmt.Println("汪汪汪！")
}

func main() {
   dog := *NewDog("小狗", 2, "公", "黄色")
   fmt.Println(dog)
   dog.Bark()
}
```

运行上述代码，控制台将输出：

> {黄色 {小狗 2 公}}
> 
> 汪汪汪！

有了Bird，Dog的实现应该不会有问题吧？

在继续之前，我有个问题要考考大家：dog变量是Dog类型，bird变量是Bird类型。那么，dog可以执行Fly()方法吗？反过来，bird可以执行Bark()方法吗？为什么？

答案是：统统**不能**。

因为Fly()方法的接收者是*Bird，Bark()方法的接收者是*Dog。**动作的接收者不同，意味着发生或执行动作的对象不同，因此不能混用。**（想想现实世界中，有谁见过小鸟犬吠，小狗起飞吗？）

但是，有一些动作确实是小狗和小鸟同时具备的，比如：吃饭（Eat）。几乎没有哪种动物（Animal）能够不吃饭而存活吧？

那么，若要实现吃饭这个动作，继续为Bird和Dog分别创建方法当然是可行的。但又没有更好的实现方式呢？

当然有！Bird和Dog都是由Animal派生而来，而吃饭（Eat）又是Animal所具有的公共动作。因此，我们便可为Animal创建一个方法，接收者是*Animal类型即可。这样一来，**因为Bird和Dog都嵌入了Animal类型数据，自然也就可以执行Animal的动作了**。

下面，创建一个接收者是*Animal类型的方法，名为Eat()。为了体现动作的作用对象，我们在Eat()方法中，将Name属性值一并输出到控制台中。具体代码如下：

```Go
type Animal struct {
   Name   string
   Age    int
   Gender string
}

func (a *Animal) Eat() {
   fmt.Println(a.Name, "我要吃到饱！")
}
```

下面，回到main()函数中，使用bird和dog变量逐层调用Eat()方法。具体代码如下：

```Go
func main() {
   bird := *NewBird("小鸟", 1, "公", "绿色")
   bird.CommonAnimal.Eat()
   dog := *NewDog("小狗", 2, "公", "黄色")
   dog.CommonAnimal.Eat()
}
```

运行程序，控制台将输出：

> 小鸟 我要吃到饱！
> 
> 小狗 我要吃到饱！

通过上面的输出结果可以看出：虽然它们调用的是公共方法，但由于执行该动作的变量不同，最终的输出结果也会随之变化。这便是我们想要的效果。

## 匿名结构体嵌套

Go语言语法还允许开发者以一种更为简单的方式嵌套结构体使用，这种更简单的方式便是嵌套匿名结构体。在后期使用时，也会被简化。以Bird类型结构体为例，下面的写法是完全合法的：

```Go
type Animal struct {
   Name   string
   Age    int
   Gender string
}

func (a *Animal) Eat() {
   fmt.Println(a.Name, "我要吃到饱！")
}

type Bird struct {
   string
   Animal
}

func NewBird(name string, age int, gender string, wingColor string) *Bird {
   return &Bird{
      wingColor,
      Animal{
         name,
         age,
         gender,
      },
   }
}

func (b *Bird) Fly() {
   fmt.Println("我起飞啦！")
}

func main() {
   bird := *NewBird("小鸟", 1, "公", "绿色")
   //访问string类型成员
   fmt.Println(bird.string)
   //访问Name成员
   fmt.Println(bird.Name)
   bird.Eat()
```

上述代码运行后，控制台将输出：

> 绿色
> 
> 小鸟
> 
> 小鸟 我要吃到饱！

请大家将这种简化写法与普通的写法对比，重点关注Bird结构体的定义方式、NewBird()构造函数的实现方式以及main()函数中，bird变量的字段取值和方法调用方式。

## 总结

🎉 恭喜，您完成了本次课程的学习！

📌 以下是本次课程的重点内容总结：

- 使用结构体实现继承。
    

本讲是结构体系列专题的第三篇，也是这个专题的最后一篇。在本讲中，需要重点掌握的就是“继承”了。首先要明确继承中“父”与“子”的概念，知道它们之间的关系——“子结构体”扩展了“父结构体” 。以及它们之间的区别：“父结构体”是概括的，抽象的，那么“子结构体”就是具体的、详细的。接着便是利用Go语言中的结构体来实现继承的语法知识了。

最后，从Go语言的语法设计中，我们还可得到如下结论：

**Go语言中的****继承****是通过内嵌或组合来实现的，在Go语言中，相比较于继承，组合更受青睐。**

灵活地使用结构体，通过嵌套的方式可以描述结构非常复杂的数据。在执行网络请求场景中，解析服务端返回的JSON格式通常会用到结构体嵌套的技能。有关这部分的扩展阅读资料请参考：[Go语言使用匿名结构体解析JSON数据 (biancheng.net)](https://link.juejin.cn/?target=http%3A%2F%2Fc.biancheng.net%2Fview%2F76.html)。

➡️ 在下次课程中，我们会介绍Go语言中接口的使用技巧，具体内容是：

- 接口的定义和使用
    

# 接口 一 ｜ 制定“行动法则”

从本讲开始，我会介绍Go语言中的接口部分，我将用三讲的篇幅为大家讲解。本讲是第一讲的内容，将为大家介绍的知识点是：

- 接口的定义和使用
    

在正式开始讲解之前，我们还需要明确一个必备的概念——接口的目的，或者说是接口的作用。

## 接口的作用

概括地说，接口的作用实际上就是规定了对象的“行动法则”。

一方面，举例来说：一个“学生”对象，他能做的事情有很多：学习、锻炼、吃饭、睡觉、打电子游戏等等。当这个对象来到学校之后，打电子游戏、睡觉这类行为就会受到禁止或者是限制了。换句话说，在某些场景中，我们会**规范某个对象的行为，使其受控**。那么，想要实现这种规范（或者说是控制），就要用到接口了。

另一方面，得益于接口的编程设计模式。**使用者（调用接口的一方）无需关注某个动作的具体实现；实现者（具体执行某个行为的一方）也无需关心使用方式。**

用比较生动的方式来阐述，使用者的内心戏就是：我现在想让你做这件事情，我不管你用什么方法，反正得给我个结果。实现者的内心戏就是：我会做也能做好这件事情，我不管是谁让我做，反正我会把结果给你。

映射到现实生活中，假设有“老师”和“学生”两种对象，都会执行“上课”的行为。对于老师而言，上课的具体实现方式便是讲课；对于学生而言，上课的具体实现方式便是听课。如此一来，一旦使用老师对象去执行上课的行为，讲课便会发生。反过来，一旦使用学生对象去执行上课的行为，听课便会发生。

同时，由于“上课”这个行为规范了老师只能“讲课”，所以尽管老师有逛街、看电影等等行为，但都不会在上课时执行；相应地，“上课”行为也规范了学生只能“听课”，所以尽管学生有睡觉、玩游戏等等行为，也都不会在上课时去做。

大家看，整个上课的流程由于有了规范，**所有涉及到的对象的行为便会“受控”**。由于对象都按照规范去做，那么行为一旦开始，**每个对象便会执行各自的具体行为**。这便是使用接口的意义。

在实际开发之中，接口的使用非常普遍。比如：我们在使用淘宝App进行商品搜索时，其结果页往往会是一个搜索结果列表，其中通常包含了商品的概况以及图片。

就拿图片来说吧，一般加载和显示图片会采用“本地缓存”的机制，一方面节省用户流量，另一方面加快了图片的显示速度。作为列表，无需关心缓存或是网络是如何具体查找和返回图片数据的，只要先看看本地有没有数据，没有再去网上下载就完工了。而具体的查找和返回数据则交给负责缓存管理和负责网络下载的执行者去做，它们遵循通用的行为准则。

既然说到图片加载，我们不妨就以此为例讲解Go语言中接口的使用。一般来说，**接口分为两个步骤来准备，首先是定义（行为规范），然后是相关对象的实现（具体的操作），准备好后便可在后续的代码中使用接口了。**

## 接口的定义

在Go语言中，定义接口的格式如下：

```Go
type interface_name interface{
    function_name( [params] ) [return_values]
    ...
}
```

其中，type关键字表示要自定义类型；interface_name是自定义的接口名；interface表示接口类型；由大括号包裹的部分定义了要被实现方法，一个接口中可以同时存在一个或多个方法。function_name是方法名；params是方法所需的参数；return_values是方法的返回值。params和return_values可以省略，也可以存在一个或多个。

对于本例而言，接口的目的在于规范图片加载的流程。为了讲解方便，我在此将图片加载的过程简化为查找并下载图片一个步骤。

在查找并下载图片时，需要图片下载地址作为依据，并将返回图片的实际数据。因此，我们定义一个名为imageLoader的接口，接口中包含FetchImage()方法，该方法需要string类型的变量作为参数，表示下载地址，返回string类型（在实际开发中通常是byte[]），表示图片数据。

`💡 提示： 注意到接口的命名（imageLoader）特点了吗？在为接口命名时，一般会在单词后面加上er后缀。接口中的方法名（FetchImage()）首字母大小写决定了该方法的可访问范围。`

具体代码如下：

```Go
// ImageDownloader 图片加载接口
type ImageDownloader interface {
        // FetchImage 获取图片，需要传入图片地址，方法返回图片数据
        FetchImage(url string) string
}
```

如此，接口的定义便完成了。

## 接口的实现

接下来，就到了接口的实现环节。

接口的实现，实际上就是指实现具体的行为。比如：本例中的从缓存中加载或从网络上下载图片的具体方法。

我们先来实现从本地缓存中获取图片数据的部分。通过前面对结构体的学习，我们已经掌握了如何使用结构体来表示一个对象，以及执行对象的方法。现在，我们一同定义负责本地缓存管理的结构体。具体代码如下：

```Go
type fileCache struct {
}
```

为了讲解方便，我在这里省略了这个结构体的内部构造。

接下来，便是实现具体的接口方法了。在Go语言中，实现接口的格式如下：

```Go
func (struct_variable struct_name) function_name([params]) [return_values] {
   // 方法实现 
}
```

其中，struct_name_variable和struct_name一起，表示作用的对象。对于本例而言，则是*fileCache类型的变量。紧接着的function_name是方法名，params指的是方法所需的参数，return_values指的是方法的返回值。其中，params和return_values是可选的，也允许有多个值。

套用到本例，我们编写作用于*fileCache的接口实现，代码如下：

```Go
//FetchImage接口实现
func (f *fileCache) FetchImage(url string) string {
        return "从本地缓存中获取图片：" + url
}
```

对比FetchImage()方法的接口声明：

```Go
// FetchImage 获取图片，需要传入图片地址，方法返回图片数据
FetchImage(url string) string
```

发现了吗？在实现方法时，需要满足两个条件：

- 第一是**接口中定义的的方法与实现接口的类型方法格式一致**。这要求不仅方法名称相同，参数和返回值也要相同；
    
- 第二就是**接口中定义的所有方法全部都要实现**。
    

如法炮制，继续定义负责从网络下载图片的结构体以及作用于该结构体的接口实现：

```Go
//定义从网络下载图片的结构体
type netFetch struct {
}
//FetchImage接口实现
func (n *netFetch) FetchImage(url string) string {
        return "从网络下载图片：" + url
}
```

到此，接口的定义和实现就都已完成。下一步就是回到main()函数中使用它们了。

## 接口的调用

来到main()函数，定义一个ImageDownloader类型的变量，然后通过new(fileCache)函数为其赋值，随后便可通过这个变量调用从缓存中加载图片的方法。类似地，通过new(netFetch)为其赋值，便可通过这个变量调用从网络上下载图片的方法。

`💡 提示： 为何ImageDownloader类型的变量可以通过new(fileCache)或new(netFetch)进行赋值呢，你知道原因吗？`

从具体的业务需求分析，我们应首先检查本地缓存是否存在相应的图片数据，当找不到时再从网络中获取。因此，整个接口调用部分的示例代码如下：

```Go
func main() {
        //从本地缓存中获取数据
        var imageLoader ImageDownloader
        imageLoader = new(fileCache)
        data := imageLoader.FetchImage("https://www.example.com/a.png")
        fmt.Println(data)
        if data == "" {
                // 当本地缓存中没有数据时，从网络下载
                var imageLoader2 ImageDownloader
                imageLoader2 = new(netFetch)
                data2 := imageLoader2.FetchImage("https://www.example.com/a.png")
                fmt.Println(data2)
        }
}
```

如上所示，代码的逻辑将首先检查本地缓存，当返回值为空字符串（""）时，即表示本地无缓存。此时，应考虑去网络上下载图片。

将本讲示例代码汇总并运行，控制台可得如下输出：

> 从本地缓存中获取图片：[www.example.com/a.png](https://link.juejin.cn/?target=https%3A%2F%2Fwww.example.com%2Fa.png)

修改针对*fileCache的FetchImage()方法，使其返回值为空字符串（""），再次运行程序，控制台上的输出将变为：

> 从网络下载图片：[www.example.com/a.png](https://link.juejin.cn/?target=https%3A%2F%2Fwww.example.com%2Fa.png)

怎么样，在Go语言中使用接口是不是很简单呢？

## 总结

🎉 恭喜，您完成了本次课程的学习！

📌 以下是本次课程的重点内容总结：

- 接口的定义和使用
    

本讲是接口系列专题的第一篇。在本讲中，我们首先明确了一个概念——使用接口的目的是什么。概括地说有两点：一是**规范某个对象的行为，使其受控**；二是**接口的使用者和实现者各司其职**，互不干涉。

然后，我们分为三个步骤介绍了接口的一般使用流程，包括**接口的定义**、**接口的实现**以及**接口方法的调用**。并以模拟图片加载为例，模拟了从本地缓存中加载和从网络上下载图片两种方式显示图片的流程。

最后，还需要补充一个知识点——**一种类型可以实现多个接口，多种类型可以实现相同的接口**。看上去是不是像绕口令？别着急，不妨再写个示例来演示该特性。有关这部分的内容，感兴趣的朋友可以阅读这一篇参考文章（实际上，只要掌握了本讲的内容，这一特性是非常容易理解的）：[Go语言类型与接口的关系 (biancheng.net)](https://link.juejin.cn/?target=http%3A%2F%2Fc.biancheng.net%2Fview%2F79.html)

好了，本讲就到这里。

➡️ 在下次课程中，我们会介绍Go语言中接口的更多使用技巧，具体内容是：

- 空接口与泛型
    

# 接口 二 ｜ 空接口与泛型，类型中的“万能牌”

从上一讲开始，开始了接口专题的学习，具体来说是Go语言中接口的定义和使用。本讲继续针对接口进行深入讲解，包含以下内容：

- 空接口与泛型
    
- 类型断言
    

什么是空接口，什么又是泛型呢？

**所谓****泛型****，可以简单地理解为****数据类型****中的“万能牌”，它能存放任何类型的数据。Go语言中的空接口正是为了实现泛型所采用的手段。**

## 泛型初体验

什么时候该使用泛型呢？举个例子，如果我们想要封装一个函数，该函数的作用便是实现传入参数数据的原样输出，该如何做呢？

利用我们已经掌握的知识，写出的代码可能会是这样：

```Go
func main() {
   dataOutput("Hello")
}

func dataOutput(data string) {
   fmt.Println(data)
}
```

直接运行这段程序，控制台会输出：

> Hello

看似没有问题，但如果传入的参数不是string类型，而是数字型、布尔型呢？显然，程序是无法编译通过的，因为类型不匹配。

当然，我们也可以编写多个函数，来匹配不同的参数类型，比如：

```Go
func main() {
   stringDataOutput("Hello")
   intDataOutput(123)
}

func stringDataOutput(data string) {
   fmt.Println(data)
}

func intDataOutput(data int) {
   fmt.Println(data)
}
```

如此确实可以实现，但代码整体不够优雅。况且这还只是两种类型，要是更多，日后的代码维护成本就会直线飙升了。

细心的朋友会发现，尽管类型不同，但函数体内实际执行的逻辑都是相通的。那么，有没有一种办法使函数的参数不再受限呢？当然有，那就是使用泛型。

**泛型****是类型中的“万能牌”**，使用泛型作为函数参数，实际上就相当于告诉调用者：“我能兼容任何类型的参数，尽管将数据传给我就是了。”泛型以超级宽广的胸怀接纳所有类型的数据。**在Go语言中的泛型，则使用空接口来实现。** 而所谓的“空接口”，使用代码表示非常简单，就是：

```Go
interface{}
```

和普通接口的定义格式不同，空接口内部无需填写任何方法。

**空接口能接纳所有类型的数据，因此可以将任何类型的数据赋值给它的变量**，请大家阅读下面这段代码：

```Go
var anyTypeValue interface{}

func main() {
   anyTypeValue = 123
   anyTypeValue = true
   anyTypeValue = "Hello"
}
```

这段代码完全合法，可以编译、运行。

另一方面，**在函数参数中使用空接口，可以使其能接受所有类型的数据传入。** 以本讲一开始的示例举例，若要编写一个函数，实现传入参数数据的原样输出，只需按如下编写代码即可：

```Go
func main() {
   dataOutput("Hello")
   dataOutput(123)
   dataOutput(true)
}

func dataOutput(data interface{}) {
   fmt.Println(data)
}
```

程序运行结果为：

> Hello
> 
> 123
> 
> true

如此编码，是不是比写一堆类似的函数要方便、简洁很多呢？还能节省开发和维护的时间。

`💡 提示： 猜一猜，如果在dataOutput()函数中输出data变量的类型，将会如何输出呢？各位朋友不妨亲自动手一试，获取数据类型的函数是reflect.TypeOf(i interface{})。注意到了吗？这个函数所需的参数类型也是空接口类型，即泛型。`

## 货车容量计算器

品尝到空接口的“甜头”之后，我们来实战空接口的使用，进一步体会使用它带来的好处。

现在，我们计划进行一次搬家，正在预估需要多大容量的货车来存放全部家当。

为了讲解方便，本例将简化各种家具家电的体积计算方式。把它们简单粗暴地分为正方体、长方体和圆柱体三种体积形式，这三种形状的物品分别对应代码中的三种结构体类型。

此外，还需实现为这三种形状的物品编写体积计算的方法。如此一来，我们便可通过调用这个体积计算的方法，将其计算结果累加在一起，便可得知需要至少多大容量的货车了。

还记得如何定义一个结构体吧？以正方体为例，计算体积仅需要知道边长就可以了。所以我们定义一个名为cube的结构体，其中包含float64类型的length变量，表示边长，具体代码如下：

```Go
// 正方体
type cube struct {
   // 边长
   length float64
}
```

接着，定义一个方法，名为cubeVolume，表示计算正方体的体积。作用于*cube类型，返回float64类型值，具体代码为：

```Go
// 正方体的体积计算
func (c *cube) cubeVolume() float64 {
   return c.length * c.length * c.length
}
```

如上，关于正方体的结构体和体积计算方法已经全部实现完成。依葫芦画瓢，继续实现长方体和圆柱体对应的结构体和体积计算方法。以下是具体的代码片段：

```Go
// 长方体
type cuboid struct {
   // 长
   length float64
   // 宽
   width float64
   // 高
   height float64
}

// 长方体的体积计算
func (c *cuboid) cuboidVolume() float64 {
   return c.length * c.width * c.height
}

// 圆柱体
type cylinder struct {
   // 直径
   diameter float64
   // 高度
   height float64
}

// 圆柱体的体积计算
func (c *cylinder) cylinderVolume() float64 {
   return math.Pi * (c.diameter / 2) * (c.diameter / 2) * c.height
}
```

接下来是本讲的另一个重点知识。如果我们想用同样一个函数来计算所有类型物体的体积，那么“认清”家具的种类就是非常必要的一环。换言之，当传入这个函数的参数是正方体，则需要调用cubeVolume()函数进行计算；当传入这个函数的参数是长方体，则需要调用cuboidVolume()函数进行计算；当传入这个函数的参数是正方体，则需要调用cylinderVolume()函数进行计算。

**在Go语言中，用来判断某个数据是否属于某种类型的方法被称为“类型断言”。**

类型断言的使用格式为：

```Go
value, ok := x.(T)
```

其中，x是指某个变量，T表示类型，value是将x变量转换为T类型之后的值，ok是布尔类型，表示x是否属于T类型。

看上去有些绕口，我们用实际的例子来做演示。

前面说过，我们要实现一个函数，传入空接口类型的参数以便接收不同类型形状的家具，然后在这个函数中计算体积并返回最终的计算值。我们先以正方体为例，具体代码如下：

```Go
// 计算某个物体的体积
func calcSize(material interface{}) float64 {
   cubeMaterial, cubeOk := material.(cube)
   if cubeOk {
      return cubeMaterial.cubeVolume()
   } else {
      return 0
   }
}
```

请大家仔细阅读这段代码，函数体内首行便进行了类型断言。material是传入该函数的参数，material.(cube)表示要判断material变量是否属于cube（正方体）类型。这种判断最终将返回两个结果，一个是cubeOk，它时布尔类型的值，当该值为true时，表示material是cube类型，反之则不是。另一个是cubeMaterial，它是将material变量转换为cube类型之后的变量，以便后续用它参与运算。

理解了函数中的首行代码，后面的代码便很好理解了。当cubeOK为true，即material属于cube时，使用转换后的cubeMaterial变量执行cubeVolume()方法，最终返回正方体的体积。

接下来，请大家自行编码实现长方体和圆柱体的类型断言和体积计算。

最后，整个程序完整的代码如下：

```Go
package main

import (
   "fmt"
   "math"
)

func main() {
   truckSize := 0.0
   // 声明空接口类型变量materials，存放各种不同体积的家具
   var materials []interface{}
   materials = append(materials, cube{12.5})
   materials = append(materials, cuboid{25, 13, 60})
   materials = append(materials, cylinder{5, 25.3})
   // 遍历materials切片，依次计算每个家具的体积，并相加求和
   for _, singleMaterial := range materials {
      truckSize += calcSize(singleMaterial)
   }
   fmt.Println(truckSize)
}

// 计算某个物体的体积
func calcSize(material interface{}) float64 {
   cubeMaterial, cubeOk := material.(cube)
   cuboidMaterial, cuboidOk := material.(cuboid)
   cylinderMaterial, cylinderOk := material.(cylinder)
   if cubeOk {
      return cubeMaterial.cubeVolume()
   } else if cuboidOk {
      return cuboidMaterial.cuboidVolume()
   } else if cylinderOk {
      return cylinderMaterial.cylinderVolume()
   } else {
      return 0
   }
}

// 正方体
type cube struct {
   // 边长
   length float64
}

// 正方体的体积计算
func (c *cube) cubeVolume() float64 {
   return c.length * c.length * c.length
}

// 长方体
type cuboid struct {
   // 长
   length float64
   // 宽
   width float64
   // 高
   height float64
}

// 长方体的体积计算
func (c *cuboid) cuboidVolume() float64 {
   return c.length * c.width * c.height
}

// 圆柱体
type cylinder struct {
   // 直径
   diameter float64
   // 高度
   height float64
}

// 圆柱体的体积计算
func (c *cylinder) cylinderVolume() float64 {
   return math.Pi * (c.diameter / 2) * (c.diameter / 2) * c.height
}
```

程序运行的结果为：

> 21949.889338348887

如此，我们便可有依据地选择货车了。

你注意到了吗？在main()函数中，我**将空接口类型作为切片中的元素**放在了名为materials的切片中。这在实际开发中是非常巧妙的使用空接口的方式，它可以规避数据类型的不同，将不同类型的数据存放于同一个切片/数组中，对于组织大量具有不同类型的数据是非常有效的做法。

## 总结

🎉 恭喜，您完成了本次课程的学习！

📌 以下是本次课程的重点内容总结：

- 空接口与泛型
    
- 类型断言
    

本讲是接口系列专题的第二篇。在本讲中，我们首先了解到泛型到底是什么，以及Go语言中将使用空接口实现泛型。接着，我们使用了一个数据原样输出的例子演示了空接口的简单使用。

接着，以搬家选货车为示例，进一步强化了空接口的使用方法，并介绍了Go语言中的类型断言，使用分支的方式实现判断空接口中变量的类型。

在实际开发中，空接口和类型断言往往同时出现，配套使用。

好了，本讲就到这里。

➡️ 在下次课程中，我们会介绍Go语言中接口的更多使用技巧，具体内容是：

- 接口使用的注意事项
    

# 接口 三 ｜ 灵活、安全地运用接口