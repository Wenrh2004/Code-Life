## 切片

专门存放**不定元素个数**的**相同类型元素**的数据结构，叫做**切片（Slice）**在Go语言中，切片的声明一般格式为：

```Go
var slice_name []Type
```

其中，`var`关键字用于==声明变量==；`slice_name`表示==切片名==；`Type`表示==元素类型==。

```
💡 提示： 注意到了吗？声明切片和数组的区别仅仅是去掉了中括号中的元素个数！
```

对于本例，代码实现为：

```Go
var resultSlice []int
❗️ 注意： 和数组类似，切片中的元素也不限制值的类型，但要求所有元素均为相同的类型。
```

完成切片的声明后，就来到赋值环节。

与数组不同，为切片赋值可以理解为“**扩充**”。在一开始，切片里面的元素个数为0。“扩充”一个值，就相当于为切片中的第一个元素赋值。赋值后，切片的元素个数就变成了1。若再次“扩充”，则相当于为切片中的第二个元素赋值。赋值后，切片的元素个数就变成了2，以此类推……

在Go语言中，为切片“扩充”需要使用`append()`函数，使用格式如下：

```Go
slice_name = append(slice_name, value)
```

其中，`slice_name`表示**已声明的切片变量名**，`value`表示**具体的数据值**。

值得一提的是，**append()函数本身并不会改变原有切片**，只是将切片“扩容”后的结果作为函数返回值。因此，需要将“扩容”后的结果再次（即函数返回值）赋值给slice_name，才能真正使slice_name发生改变。

对于本例而言，若要“扩充”切片，添加值为2的元素，代码实现为：

```Go
resultSlice = append(resultSlice, value)
```

到此，我们掌握了切片的声明和赋值方法，接下来又到了修改原有代码的时候。修改后的代码如下：

```Go
func main() {
   var resultSlice []int
   for i := 2; i < 30; i++ {
      //假定i为素数
      flag := true
      for j := 2; j < i; j++ {
         if i%j == 0 {
            //当i能被某个整数整除时，不是素数
            flag = false
         }
      }
      //如果依旧为true，则i为素数
      if flag {
         //将素数存放到resultArray数组中
         resultSlice = append(resultSlice, i)
      }
   }
   fmt.Println(resultSlice)
}
```

显然，由于切片在赋值时无需关注下标，因此连原有的arrayIndex变量也省了。

运行这段代码，控制台将输出：

> [2 3 5 7 11 13 17 19 23 29]

接下来，如果想查找100以内的素数，该如何修改呢？答案是——只需要修改循环终止的条件即可（即将i < 30改为i < 100），是不是更方便呢？

在实际项目中，切片的使用其实更为广泛。