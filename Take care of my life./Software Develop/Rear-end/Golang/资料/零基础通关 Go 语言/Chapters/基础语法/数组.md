## 数组

由**相同类型**的**个数确定**的值组成的集合称为**数组**，数组中的每个值又称为数组中的“元素”。

```
❗️ 注意： 数组中的元素并不限制值的类型，但要求所有元素均为相同的类型。
```

对于本例而言，便可声明一个总共有4个元素的数组来管理素数结果。Go语言中声明数组的一般格式为：

```Go
var array_name [quantity]Type
```

其中，`var`关键字用于==声明变量==；`array_name`表示==数组名==；`quantity`表示==数组元素个数==；`Type`表示==元素类型==。

因此，对于本例，便可声明名为“resultArray”的数组变量，其元素个数为4，类型为int，代码为：

```Go
var resultArray [4]int
```

声明后即可为单个元素赋值了。和其它的编程语言类似，要为数组中的某个元素赋值，格式为：

```Go
array_name[index] = Value
```

其中，`array_name`表示已声明的数组名；`index`表示数组中的第N个元素，称之为==索引==或==下标==，通常是包含0的正整数；`Value`则表示具体的数据值。

对于本例而言，若要为数组中的第3个元素赋值为5，对应的代码为：

```Go
resultArray[2] = 5
//❗️ 注意： 数组的索引从0开始，因此索引的取值范围应该是从0至数组元素个数减1为止。如本例则为0、1、2、3。超出范围的赋值和取值将引发下标越界错误，导致程序出错。对某一索引位置的元素重复赋值将导致旧值被新值替换。
```

到此，数组的声明和赋值方法都有了，下面就来将它们结合到原有代码中吧！

```Go
func main() {
   var resultArray [4]int
   var arrayIndex int = 0
   for i := 2; i < 10; i++ {
      //假定i为素数
      flag := true
      for j := 2; j < i; j++ {
         if i%j == 0 {
            //当i能被某个整数整除时，不是素数
            flag = false
         }
      }
      //如果依旧为true，则i为素数
      if flag {
         //将素数存放到resultArray数组中
         resultArray[arrayIndex] = i
         arrayIndex++
      }
   }
   fmt.Println(resultArray)
}
```

如上代码所示，除了声明resultArray外，还声明了arrayIndex作为数组赋值时的索引之用。每次赋值结束后arrayIndex都会自增1，以便为下个元素赋值。

运行这段代码，控制台输出：

> [2 3 5 7]

如此，查找到的结果集便保存到了resultArray数组中，后面的代码便通过resultArray随时访问结果集了。

接下来思考一个问题，本例要求查找了10以内的素数。如果换成查找30以内、50以内，甚至更大范围的话，查找到的结果必然会有不同程度的增加。

如果使用数组来存放结果的话，很容易引发下标越界错误。和数组相对，Go语言还提供了一种专门存放**不定元素个数**的数据结构——[[切片]]。