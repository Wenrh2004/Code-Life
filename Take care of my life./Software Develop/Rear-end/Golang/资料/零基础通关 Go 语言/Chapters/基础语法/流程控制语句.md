流程控制语句多用于管理循环结构的运行。考虑这样一个需求：编程实现查找1-10以内的素数。

```
💡 提示： 素数又称质数，是指在大于1的自然数中，除了1和它本身以外不能被其它整数整除的自然数，2是最小的素数。
```

这一次，我们需要在已有的代码上增加，但不改变原有的代码。先来看看现有代码：

```Go
func main() {
    for i := 2; i > 0; i++ {
        if i == 2 {
            fmt.Println(i)
        }
        //假定i为素数
        flag := true
        for j := 2; j < i; j++ {
            if i%j == 0 {
                //当i能被某个整数整除时，不是素数
                flag = false
            }
        }
        //如果依旧为true，则i为素数
        if flag {
            fmt.Println(i)
        }
    }
}
```

通过阅读上述代码可以发现：

- 代码整体由一个for循环构成，初始化语句声明了变量i，从2开始（2是最小的素数），循环结束的条件是i大于0，每次循环结束后i自增1；
- 循环体内，首先判断了i是否等于2，如果是的话直接输出了i的值；
- 然后，声明了布尔类型变量flag，表明是否为素数，用于后续判断是否输出i的值；
- 接下来，使用循环结构判断i是否为素数。初始化时声明了变量j，从2开始，跳出循环的条件时j小于i，判断i是否为素数只需从2开始尝试做除法，直到i-1为止。若余数为0，则表示能被整除，此时，flag应改为false。每次循环结束后j自增1；
- 最后，判断flag的值，若flag为true，则表示i是素数，输出i，反之则不是素数。

代码运行后，控制台输出：

> 2
>
> 2
>
> 3
>
> 5
>
> 7
>
> 11
>
> 13
>
> ...

明明是查找10以内的素数，为何不停地输出这么多结果呢？请大家来找茬，看看这段代码中有哪些问题？

1. 最外层的for循环，终止条件是i大于0，但i始终是大于0的，程序一旦开始，便无法结束，陷入死循环；
2. 当i等于2时，输出了一次i的值。然而在内层的循环体中，还将再次输出。最终将输出两次2；
3. 在内层循环中，一旦i与j取余结果为0，则表明i不是素数，内层for循环结构无需再执行剩下的循环了。

解决了这3个问题，便能实现查找1-10以内的素数的需求了。要解决它们，就需要请出Go语言中的流程控制语句来“救场”了。在Go语言中，较为常用的流程控制语句有**continue**和**break**。前者的意义是立即结束本次循环，执行下一个循环；后者的意义是终止循环。

显然，解决问题1和3，只需使用break语句打断相应循环的执行即可；解决问题2，只需使用continue语句提前终止本次循环，直接执行下一次循环即可。因此，将代码改为：

```Go
func main() {
    for i := 2; i > 0; i++ {
        //当i大于10s
        if i > 10 {
            break
        }
        if i == 2 {
            fmt.Println(i)
            continue
        }
        //假定i为素数
        flag := true
        for j := 2; j < i; j++ {
            if i%j == 0 {
                //当i能被某个整数整除时，不是素数
                flag = false
                break
            }
        }
        //如果依旧为true，则i为素数
        if flag {
            fmt.Println(i)
        }
    }
}
```

运行结果为：

> 2
>
> 3
>
> 5
>
> 7